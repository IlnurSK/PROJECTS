# Шпаргалка по теории, уровень Junior+/PreMiddle PHP/Laravel
<!-- TOC -->
* [Шпаргалка по теории, уровень Junior+/PreMiddle PHP/Laravel](#шпаргалка-по-теории-уровень-juniorpremiddle-phplaravel)
  * [1) Какие типы данных существуют в PHP?](#1-какие-типы-данных-существуют-в-php)
  * [2) Расскажи мне про callable подробнее:](#2-расскажи-мне-про-callable-подробнее)
  * [3) Enum это тип данных?](#3-enum-это-тип-данных)
  * [4) Что такое замыкание в PHP?](#4-что-такое-замыкание-в-php)
  * [5) Чем отличается замыкание от обычной функции?](#5-чем-отличается-замыкание-от-обычной-функции)
  * [6) Какая область видимости переменных у функции замыкания?](#6-какая-область-видимости-переменных-у-функции-замыкания)
  * [7) Чем отличается статическое замыкание от обычного замыкания?](#7-чем-отличается-статическое-замыкание-от-обычного-замыкания)
  * [8) Почему статическое быстрее, а обычное помедленнее?](#8-почему-статическое-быстрее-а-обычное-помедленнее)
  * [9) Что такое сборщик мусора?](#9-что-такое-сборщик-мусора)
  * [10) Какие виды ссылок есть в PHP?](#10-какие-виды-ссылок-есть-в-php)
  * [11) Что такое stdClass() ?](#11-что-такое-stdclass-)
  * [12) Что такое переменная переменной? Для чего и где это используется?](#12-что-такое-переменная-переменной-для-чего-и-где-это-используется)
  * [13) Что такое рекурсия?](#13-что-такое-рекурсия)
  * [14) Что происходит при бесконечной рекурсии?](#14-что-происходит-при-бесконечной-рекурсии)
  * [15) Основные отличия интерфейса от абстрактного класса?](#15-основные-отличия-интерфейса-от-абстрактного-класса)
  * [16) Для чего нужны сессии и где они хранятся?](#16-для-чего-нужны-сессии-и-где-они-хранятся)
  * [17) Транзакции, для чего нужны и как использовать?](#17-транзакции-для-чего-нужны-и-как-использовать)
  * [18) Что такое обфускатор и как его реализовать?](#18-что-такое-обфускатор-и-как-его-реализовать)
  * [19) Что такое идемпотентность?](#19-что-такое-идемпотентность)
  * [20) Какие бывают области видимости у переменных?](#20-какие-бывают-области-видимости-у-переменных)
  * [21) Какие коды HTTP ответов бывают, и на какие группы они разделяются?](#21-какие-коды-http-ответов-бывают-и-на-какие-группы-они-разделяются)
  * [22) Какие методы HTTP запросов бывают?](#22-какие-методы-http-запросов-бывают)
  * [23) Какие виды JOIN бывают в SQL?](#23-какие-виды-join-бывают-в-sql)
  * [24) Чем отличается LEFT от RIGHT JOIN?](#24-чем-отличается-left-от-right-join)
  * [25) Какие агрегатные функции есть в SQL?](#25-какие-агрегатные-функции-есть-в-sql)
  * [26) Чем отличается HAVING от WHERE?](#26-чем-отличается-having-от-where)
  * [27) Что такое индексы в БД и для чего они нужны, какие виды индексов существуют?](#27-что-такое-индексы-в-бд-и-для-чего-они-нужны-какие-виды-индексов-существуют)
  * [28) В каких ситуациях индекс хорош, а когда плох?](#28-в-каких-ситуациях-индекс-хорош-а-когда-плох)
  * [29) ACID, что это такое?](#29-acid-что-это-такое)
  * [30) Какие бывают базы данных, и чем они различаются между собой?](#30-какие-бывают-базы-данных-и-чем-они-различаются-между-собой)
  * [31) Clickhouse, какая БД? Реляционная или нет?](#31-clickhouse-какая-бд-реляционная-или-нет)
  * [32) В каком виде хранятся данные в PostgreSQL?](#32-в-каком-виде-хранятся-данные-в-postgresql)
  * [33) Что такое Redis, где используется?](#33-что-такое-redis-где-используется)
  * [34) Какие подтипы нереляционных БД существуют?](#34-какие-подтипы-нереляционных-бд-существуют)
  * [35) Что такое Explain, в контексте БД?](#35-что-такое-explain-в-контексте-бд)
  * [36) Как используется принцип SRP (SOLID) в Laravel?](#36-как-используется-принцип-srp-solid-в-laravel)
  * [37) В какой класс лучше вывести проверку данных (валидацию) с контроллера в Laravel?](#37-в-какой-класс-лучше-вывести-проверку-данных-валидацию-с-контроллера-в-laravel)
  * [38) Какой принцип SOLID будет использован при разделении данного контроллера?](#38-какой-принцип-solid-будет-использован-при-разделении-данного-контроллера)
  * [39) Расскажи про жизненный цикл запроса в Laravel?](#39-расскажи-про-жизненный-цикл-запроса-в-laravel)
  * [40) В 10 версии Laravel существовал therm файл за что он отвечал?](#40-в-10-версии-laravel-существовал-therm-файл-за-что-он-отвечал)
  * [41) Что такое middleware в Laravel, и какой функционал он выполняет?](#41-что-такое-middleware-в-laravel-и-какой-функционал-он-выполняет)
  * [42) Что такое события в Laravel, как и где используются?](#42-что-такое-события-в-laravel-как-и-где-используются)
  * [43) Что такое обсерверы?](#43-что-такое-обсерверы)
  * [44) Как в Laravel можно ограничить количество подключений одного пользователя к ip адресу приложения?](#44-как-в-laravel-можно-ограничить-количество-подключений-одного-пользователя-к-ip-адресу-приложения)
  * [45) Как в Laravel реализовываются запросы на сторонние приложения, что для этого применяются?](#45-как-в-laravel-реализовываются-запросы-на-сторонние-приложения-что-для-этого-применяются)
  * [46) Что такое Guzzle в чем его удобство, и какую функцию он реализует в PHP?](#46-что-такое-guzzle-в-чем-его-удобство-и-какую-функцию-он-реализует-в-php)
  * [47) Можно ли по нему авторизовываться?](#47-можно-ли-по-нему-авторизовываться)
  * [48) Какая структура HTTP запроса?](#48-какая-структура-http-запроса)
  * [49) В каком элементе запроса хранятся данные по авторизации?](#49-в-каком-элементе-запроса-хранятся-данные-по-авторизации)
  * [50) Что такое Bearer?](#50-что-такое-bearer)
  * [51) Что такое Eloquent ORM, для чего используется, какие типы связи есть?](#51-что-такое-eloquent-orm-для-чего-используется-какие-типы-связи-есть)
  * [52) Что такое SQL инъекции?](#52-что-такое-sql-инъекции)
  * [53) ORM защищает от SQL инъекций? Или все равно можно получить несанкционированый доступ?](#53-orm-защищает-от-sql-инъекций-или-все-равно-можно-получить-несанкционированый-доступ)
  * [54) Что такое Job в Laravel, для чего они нужны, как они работают, кто их запускает?](#54-что-такое-job-в-laravel-для-чего-они-нужны-как-они-работают-кто-их-запускает)
  * [55) Какой инструмент в Laravel управляет этими очередями?](#55-какой-инструмент-в-laravel-управляет-этими-очередями)
  * [56) Что такое Supervisor?](#56-что-такое-supervisor)
  * [57) Сколько Worker можно запустить на 1 задачу? Для чего это делается?](#57-сколько-worker-можно-запустить-на-1-задачу-для-чего-это-делается)
  * [58) Где хранятся настройки Laravel?](#58-где-хранятся-настройки-laravel)
  * [59) Какие минусы могут возникнуть при использовании обсервера в контроллере? Например в Post при привязке тегов?](#59-какие-минусы-могут-возникнуть-при-использовании-обсервера-в-контроллере-например-в-post-при-привязке-тегов)
  * [60) Если после изменения роутинга, перестал работать проект, какие команды рекомендуется использовать в Laravel?](#60-если-после-изменения-роутинга-перестал-работать-проект-какие-команды-рекомендуется-использовать-в-laravel)
  * [61) Вопрос по гиту, предположим начинаем свою ветку переносить в мастер, и появился конфликт, какие наши первые действия?](#61-вопрос-по-гиту-предположим-начинаем-свою-ветку-переносить-в-мастер-и-появился-конфликт-какие-наши-первые-действия)
  * [62) Что такое чери пик?](#62-что-такое-чери-пик)
  * [63) Чем отличается git merge от git rebase?](#63-чем-отличается-git-merge-от-git-rebase)
  * [64) Как работает команда git reset?](#64-как-работает-команда-git-reset)
  * [65) Что такое моковое тестирование, и область его применения?](#65-что-такое-моковое-тестирование-и-область-его-применения)
    * [Области применения:](#области-применения)
    * [Когда НЕ использовать моки:](#когда-не-использовать-моки)
  * [65) Какая проблема может возникнуть с моками при тестировании интерфейсов?](#65-какая-проблема-может-возникнуть-с-моками-при-тестировании-интерфейсов)
    * [Как это лечится?](#как-это-лечится)
  * [66) Паттерны проектирования, на какие категории делятся, и какие и где активно используются?](#66-паттерны-проектирования-на-какие-категории-делятся-и-какие-и-где-активно-используются)
    * [Порождающие (Creational) - создание объектов](#порождающие-creational---создание-объектов)
      * [Singleton (Одиночка)](#singleton-одиночка)
      * [Factory Method (Фабричный метод)](#factory-method-фабричный-метод)
      * [Builder (Строитель)](#builder-строитель)
      * [Abstract Factory - создает семейства связанных объектов](#abstract-factory---создает-семейства-связанных-объектов)
      * [Prototype - клонирование существующих объектов](#prototype---клонирование-существующих-объектов)
    * [Структурные (Structural) - композиция объектов](#структурные-structural---композиция-объектов)
    * [Adapter (Адаптер)](#adapter-адаптер)
      * [Facade (Фасад)](#facade-фасад)
      * [Decorator (Декоратор/Обертка)](#decorator-декораторобертка)
      * [Composite - древовидные структуры объектов](#composite---древовидные-структуры-объектов)
      * [Proxy - контроль доступа к объекту](#proxy---контроль-доступа-к-объекту)
    * [Поведенческие (Behavioral)](#поведенческие-behavioral)
      * [Observer (Наблюдатель)](#observer-наблюдатель)
      * [Strategy (Стратегия)](#strategy-стратегия)
      * [Iterator (Итератор)](#iterator-итератор)
      * [Command - инкапсуляция запросов как объектов](#command---инкапсуляция-запросов-как-объектов)
  * [67) Движки БД MYSQL, какие есть, в чем отличие, на что нужно обращать внимание](#67-движки-бд-mysql-какие-есть-в-чем-отличие-на-что-нужно-обращать-внимание)
    * [MyISAM (устаревший, но встречается)](#myisam-устаревший-но-встречается)
    * [InnoDB (стандарт с MySQL 5.5+)](#innodb-стандарт-с-mysql-55)
  * [68) Блокировки в БД, оптимистичные и пессимистичные, что это и что нужно знать?](#68-блокировки-в-бд-оптимистичные-и-пессимистичные-что-это-и-что-нужно-знать)
    * [Пессимистичные блокировки (Pessimistic Locking)](#пессимистичные-блокировки-pessimistic-locking)
    * [Оптимистичные блокировки (Optimistic Locking)](#оптимистичные-блокировки-optimistic-locking)
  * [69) Что такое Deadlock и как его избежать?](#69-что-такое-deadlock-и-как-его-избежать)
    * [Способы избежать deadlock:](#способы-избежать-deadlock)
      * [Единый порядок блокировки](#единый-порядок-блокировки)
      * [Короткие транзакции](#короткие-транзакции)
      * [Использование таймаутов/retry](#использование-таймаутовretry)
      * [Избегание ненужных блокировок](#избегание-ненужных-блокировок)
      * [Использование пессимистичных блокировок с умом](#использование-пессимистичных-блокировок-с-умом)
  * [70) Уровни изоляции БД](#70-уровни-изоляции-бд)
    * [4 стандартных уровня изоляции (от слабого к строгому):](#4-стандартных-уровня-изоляции-от-слабого-к-строгому)
      * [1 - Read Uncommitted (Чтение незафиксированных данных)](#1---read-uncommitted-чтение-незафиксированных-данных)
      * [2 - Read Committed (Чтение зафиксированных данных)](#2---read-committed-чтение-зафиксированных-данных)
      * [3 - Repeatable Read (Повторяемое чтение)](#3---repeatable-read-повторяемое-чтение)
      * [4 - Serializable (Сериализуемый)](#4---serializable-сериализуемый)
    * [Уровни изоляции в разных СУБД:](#уровни-изоляции-в-разных-субд)
    * [Как выбрать уровень изоляции:](#как-выбрать-уровень-изоляции)
  * [71) Оператор DISTINCT в SQL - что это и зачем применять?](#71-оператор-distinct-в-sql---что-это-и-зачем-применять)
    * [Синтаксис и варианты использования:](#синтаксис-и-варианты-использования)
    * [Важные особенности DISTINCT:](#важные-особенности-distinct)
      * [Производительность](#производительность)
      * [Работа с NULL значениями](#работа-с-null-значениями)
      * [С агрегатными функциями](#с-агрегатными-функциями)
    * [Когда использовать DISTINCT:](#когда-использовать-distinct)
* [Отдельный раздел, который нужно будет объединить с основным и разбить на подразделы](#отдельный-раздел-который-нужно-будет-объединить-с-основным-и-разбить-на-подразделы)
  * [Какой основной протокол интернета?](#какой-основной-протокол-интернета)
  * [Какие есть версии HTTP протокола? Какие их отличия?](#какие-есть-версии-http-протокола-какие-их-отличия)
    * [Ключевые отличия между версиями HTTP:](#ключевые-отличия-между-версиями-http)
      * [HTTP/1.1 vs HTTP/2:](#http11-vs-http2)
      * [HTTP/2 vs HTTP/3:](#http2-vs-http3)
    * [Какой протокол под HTTP?](#какой-протокол-под-http)
      * [Классика (HTTP/1.1 и HTTP/2):](#классика-http11-и-http2)
      * [Новая школа (HTTP/3):](#новая-школа-http3)
  * [Директива DECLARE в контексте PHP, что это и зачем?](#директива-declare-в-контексте-php-что-это-и-зачем)
    * [declare(strict_types=1)](#declarestrict_types1)
    * [declare(ticks=1);](#declareticks1)
    * [declare(encoding='...');](#declareencoding)
    * [Область действия DECLARE в PHP:](#область-действия-declare-в-php)
  * [Директивы REQUIRE/INCLUDE](#директивы-requireinclude)
    * [Основные различия:](#основные-различия)
  * [Файлы Composer - composer.json/composer.lock](#файлы-composer---composerjsoncomposerlock)
  * [Позднее статическое связывание (Late Static Binding)](#позднее-статическое-связывание-late-static-binding)
  * [Механизм передачи данных в PHP. Copy-on-write](#механизм-передачи-данных-в-php-copy-on-write)
  * [PSR (PHP Standard Recommendations)](#psr-php-standard-recommendations)
    * [Основные PSR:](#основные-psr)
      * [PSR-4](#psr-4)
  * [SOLID](#solid)
    * [Single Responsibility Principle (Принцип единой ответственности)](#single-responsibility-principle-принцип-единой-ответственности)
    * [Open-Closed Principle (Принцип Открытости/Закрытости)](#open-closed-principle-принцип-открытостизакрытости)
    * [Liskov Substitution Principle](#liskov-substitution-principle)
    * [Interface Segregation Principle](#interface-segregation-principle)
    * [Dependency Inversion Principle](#dependency-inversion-principle)
  * [REST API](#rest-api)
    * [Хороший REST API:](#хороший-rest-api)
    * [Плохой REST API:](#плохой-rest-api)
  * [CORS (Cross-Origin Resource Sharing)](#cors-cross-origin-resource-sharing)
    * [Проблема, которую решает:](#проблема-которую-решает)
    * [Как работает CORS:](#как-работает-cors)
  * [Тестирование](#тестирование)
    * [Unit (Модульные) тесты](#unit-модульные-тесты)
    * [Integration (Интеграционные) тесты](#integration-интеграционные-тесты)
    * [3. Feature (Функциональные) тесты](#3-feature-функциональные-тесты)
    * [Моки внешних HTTP-запросов:](#моки-внешних-http-запросов)
    * [Практика в Laravel:](#практика-в-laravel)
    * [Ключевое правило для запоминания:](#ключевое-правило-для-запоминания)
  * [Active Record / Data Mapper](#active-record--data-mapper)
    * [Active Record (Laravel / Eloquent ORM)](#active-record-laravel--eloquent-orm)
    * [Data Mapper (Symfony / Doctrine ORM)](#data-mapper-symfony--doctrine-orm)
<!-- TOC -->

## 1) Какие типы данных существуют в PHP?
- **Скалярные**: bool, int, float, string

- **Составные**: array, object, callable, iterable

- **Специальные**: resource, null, Enum

- **Псевдотипы**: mixed, void, never

## 2) Расскажи мне про callable подробнее:
```php
// Функция
$func = 'strlen';

// Метод объекта
$callable = [$object, 'methodName'];

// Статический метод
$staticCallable = ['ClassName', 'staticMethod'];
```

## 3) Enum это тип данных?
**Enum (перечисление)** — это специальный тип данных, который представляет собой ограниченный набор именованных значений. В PHP, начиная с версии 8.1, Enums реализованы как особый вид классов.

## 4) Что такое замыкание в PHP?
**Замыкание (Closure)** в PHP — это особый вид анонимной функции (функции без имени), которая обладает "памятью": она способна захватывать и получать доступ к переменным из той области видимости, в которой была создана, даже после того, как эта родительская область видимости перестала существовать.

## 5) Чем отличается замыкание от обычной функции?
Главное отличие замыкания от обычной функции в PHP заключается в области видимости переменных (scope) и способности захватывать эти переменные. А также именование и объявление.

## 6) Какая область видимости переменных у функции замыкания?
Область видимости переменных у функции замыкания — это двойная (или комбинированная) область видимости.

## 7) Чем отличается статическое замыкание от обычного замыкания?
Статическое замыкание не имеет доступа к `$this`, не привязано к объекту-контексту, нельзя перепривязать. НЕ держит ссылку на объект, поэтому легковесное, и может быть удален сборщиком мусора (Предотвращает утечки памяти). Лучше для утилитарных функций.

## 8) Почему статическое быстрее, а обычное помедленнее?
Потому что оно не выполняет логику связывания с объектом и, следовательно, требует меньше шагов для выполнения

## 9) Что такое сборщик мусора?
**Сборщик мусора (Garbage Collector, GC)** — это механизм в языках программирования с автоматическим управлением памятью (таких как PHP, Java, Python), который автоматически находит и удаляет объекты или данные, которые больше не используются приложением.

**Его основная задача** — освобождать оперативную память, чтобы предотвратить её переполнение (утечки памяти) и сделать процесс разработки более простым.

## 10) Какие виды ссылок есть в PHP?
- **Жесткие ссылки (&)** - прямое связывание переменных
- **Ссылки на объекты** - объекты всегда передаются по ссылке
- **Символические ссылки ($$var)** - динамические имена переменных
- **Ссылки в функциях** - изменение переданных параметров
- **Ссылки в массивах** - изменение элементов при переборе
- **Callable ссылки** - ссылки на функции и методы
- **Ссылки в замыканиях** - захват переменных по ссылке

## 11) Что такое stdClass() ?
**stdClass** — это специальный, встроенный класс в PHP, который служит базовым, анонимным (или пустым) контейнером для данных. Он не имеет никаких методов, определённых пользователем, и по сути является эквивалентом универсального, безымянного объекта.

## 12) Что такое переменная переменной? Для чего и где это используется?
**Переменная переменной** — это переменная, имя которой динамически определяется значением другой переменной. `($$)`.

## 13) Что такое рекурсия?
**Рекурсия (Recursion)** — это метод в программировании, при котором функция вызывает саму себя непосредственно или опосредованно (через другую функцию) для решения задачи.

## 14) Что происходит при бесконечной рекурсии?
При бесконечной рекурсии происходит переполнение стека **(Stack Overflow)**, что в итоге приводит к аварийному завершению (остановке) выполнения скрипта PHP.

## 15) Основные отличия интерфейса от абстрактного класса?
**Интерфейс** 
 - Только контракт (методы без тела)
 - Методы только `public`
 - Не может иметь свойств (только константы)
 - Класс может реализовать много интерфейсов
 - Используется для описания что класс должен уметь делать

**Абстрактный класс** 
 - Может содержать и контракт, и готовую реализацию
 - Методы могут быть `public/protected/private`
 - Может иметь любые свойства
 - Класс может наследовать только один абстрактный класс
 - Используется для описания общего поведения и структуры

## 16) Для чего нужны сессии и где они хранятся?
**Сессии** — это механизм для сохранения данных между разными запросами от одного пользователя. Они позволяют **"помнить"** состояние пользователя при переходе между страницами.

**Сессии нужны для:** 
 - Сохранения состояния между запросами
 - Аутентификации и авторизации
 - Корзин покупок
 - Многошаговых форм
 - Пользовательских настроек

**Где хранятся:** На сервере хранятся файлы 
 - **Файлы** - по умолчанию
 - **База данных** - для кластеров и больших проектов
 - **Redis/Memcached** - для высокой производительности)
 - У клиента хранится `cookie` с `PHPSESSID`, которая автоматически передается на сервер

## 17) Транзакции, для чего нужны и как использовать?
**Транзакции** — это механизм, который позволяет выполнять несколько SQL-запросов как единую атомарную операцию. Либо выполняются все запросы, либо ни один из них.

**ACID** свойства транзакций
- **Atomicity (Атомарность)** - Все или ничего
- **Consistency (Согласованность)** - Данные всегда в валидном состоянии
- **Isolation (Изолированность)** - Транзакции не мешают друг другу
- **Durability (Долговечность)** - Результаты сохраняются после завершения.

**Использование**: 
 - **SQL** 

```sql
START TRANSACTION/BEGIN;
COMMIT;
ROLLBACK;
```
 
 - **PDO** 

```php
try {
    $pdo->beginTransaction(); // начинаем транзакцию

    $pdo->exec("UPDATE accounts SET balance = balance - 100 WHERE id = 1");
    $pdo->exec("UPDATE accounts SET balance = balance + 100 WHERE id = 2");

    $pdo->commit(); // фиксируем изменения
} catch (Exception $e) {
    $pdo->rollBack(); // откатываем при ошибке
    echo "Ошибка: " . $e->getMessage();
}
```

 - **LARAVEL**

```php
// Автоматическая обработка транзакций
DB::transaction(function () use ($userId, $orderData) {
    // Создаем заказ
    $order = Order::create([
        'user_id' => $userId,
        'total' => $orderData['total']
    ]);
    
    // Добавляем товары
    foreach ($orderData['items'] as $item) {
        $order->items()->create([
            'product_id' => $item['product_id'],
            'quantity' => $item['quantity'],
            'price' => $item['price']
        ]);
        
        // Обновляем склад
        $product = Product::find($item['product_id']);
        $product->decrement('stock', $item['quantity']);
    }
    
    // Если произойдет любая ошибка - автоматический rollback
});

// Ручное управление
DB::beginTransaction();
try {
    // Логика...
    DB::commit();
} catch (Exception $e) {
    DB::rollBack();
    throw $e;
}
```


## 18) Что такое обфускатор и как его реализовать?
**Обфускация** — это процесс «запутывания» исходного кода, чтобы его было сложно читать и анализировать.

Код работает так же, как и до обфускации, но для человека становится непонятным.

**Используется**:
- для защиты коммерческих приложений (чтобы сложнее было украсть логику);
- для защиты от реверс-инжиниринга;
- иногда — чтобы спрятать лицензионные проверки, ключи и т. д.

**Основные техники**:
- Переименование переменных, функций, классов `preg_replace()`
- Удаление комментариев и форматирования `preg_replace()`, `trim()`
- Шифрование строковых литералов `base64_encode/base64_decode`
- Добавление ложного кода (fake)
- Динамическое выполнение `eval`, `call_user_func`

## 19) Что такое идемпотентность?
**Идемпотентность** — это свойство операции или метода, которое означает, что многократное выполнение этой операции с одинаковыми входными данными приводит к тому же самому результату (или состоянию системы), как если бы операция была выполнена только один раз.

- Идемпотентность = повторение операции не меняет результат.
- В коде: присвоение значения переменной.
- В API: GET, PUT, DELETE → идемпотентные, POST, PATCH → нет.

**Идемпотентность** — это критически важное свойство для:
- Надежных API - защита от дублирующих запросов
- Распределенных систем - безопасные retry механизмы
- Очередей сообщений - обработка дубликатов сообщений
- Финансовых операций - предотвращение двойных списаний

## 20) Какие бывают области видимости у переменных?
- **Локальная** - внутри функций, уничтожается после выполнения
- **Глобальная** - доступна везде в скрипте `global`, `$GLOBALS`
- **Статическая** - сохраняет значение между вызовами функции `static`
- **Public** - доступна отовсюду (классы)
- **Protected** - доступна в классе и наследниках
- **Private** - доступна только в объявляющем классе
- **Замыкания** - захватывают переменные из внешней области `use`

## 21) Какие коды HTTP ответов бывают, и на какие группы они разделяются?
**1xx: Информационные (Informational)**
- 100 Continue — сервер принял заголовки, можно отправлять тело запроса.
- 101 Switching Protocols — переключение протоколов (например, на WebSocket).

**2xx: Успех (Success)**
- 200 OK — всё хорошо, стандартный успешный ответ. (GET, PATCH, DELETE)
- 201 Created — ресурс успешно создан (часто при POST).
- 204 No Content — успешно, но без тела ответа (например, при DELETE иногда PUT).

**3xx: Перенаправление (Redirection)**
- 301 Moved Permanently — постоянный редирект.
- 302 Found — временный редирект.
- 304 Not Modified — ресурс не изменился (используется при кешировании).

**4xx: Ошибка клиента (Client Error)**
- 400 Bad Request — некорректный запрос. Неправильное тело запроса, невалидные данные, корявая структура JSON
- 401 Unauthorized — нужна авторизация. Запрос без авторизации или с неправильным токеном.
- 403 Forbidden — доступ запрещён, даже если авторизован (нет прав)
- 404 Not Found — ресурс не найден.
- 409 Conflict - ресурс конфликтует с текущим состоянием (например, пытаешься создать пользователя с email, который уже существует)
- 422 Unprocessable Entity — сервер понял запрос, но не может обработать (Ошибка валидации. JSON синтаксически верный, но поле email пустое или пароль короткий).
- 429 Too Many Requests - превышен лимит запросов (Rate Limiting).

**5xx: Ошибка сервера (Server Error)**
- 500 Internal Server Error — общая ошибка сервера (Сервер сдох. Апокалипсис. Логируй и чини.)
- 502 Bad Gateway — неверный ответ от прокси/шлюза.
- 503 Service Unavailable — сервис временно недоступен (например, перегрузка).
- 504 Gateway Timeout — шлюз не дождался ответа.

## 22) Какие методы HTTP запросов бывают?
**GET**
- Назначение: получить ресурс(ы).
- Тело запроса обычно не используется.
- Safe (должен только читать), идемпотентен.

**POST**
- Назначение: создать ресурс или выполнить действие.
- Обычно содержит тело (form/json).
- Не идемпотентен (каждый вызов может создать новый ресурс).

**PUT**
- Назначение: замена ресурса целиком (или создание по указанному URI).
- Обычно идемпотентен: повторные вызовы дают тот же результат.

**PATCH**
- Назначение: частичное обновление ресурса (patch — "заплатка").
- Может быть идемпотентен, но не обязателен — зависит от реализации.

**DELETE**
- Назначение: удалить ресурс.
- Обычно идемпотентен: удалить уже удалённый ресурс — результат тот же (ошибка/пустой ответ).

**HEAD**
- То же, что GET, но без тела ответа — только заголовки (используется для проверки наличия ресурса, кеширования).
- Safe, идемпотентен.

**OPTIONS**
- Возвращает, какие методы поддерживаются на данном ресурсе (CORS/policy часто используют).
- Safe, идемпотентен.

**CONNECT** — устанавливает туннель (обычно для прокси/HTTPS).

**TRACE** — эхо-запрос (диагностика) — редко и обычно блокируется (опасно).

## 23) Какие виды JOIN бывают в SQL?
- INNER JOIN
- LEFT JOIN (LEFT OUTER JOIN)
- RIGHT JOIN (RIGHT OUTER JOIN)
- FULL OUTER JOIN
- CROSS JOIN

## 24) Чем отличается LEFT от RIGHT JOIN?
Какая таблица будет главная левая (FROM) или правая (JOIN))

## 25) Какие агрегатные функции есть в SQL?
```sql
COUNT();
SUM();
AVG();
MIN()/MAX();
STRING_AGG();
ARRAY_AGG();
```
## 26) Чем отличается HAVING от WHERE?
**WHERE** — фильтрует строки ДО группировки (фильтр на SELECT)

**HAVING** — фильтрует результаты ПОСЛЕ группировки (фильтр на GROUP BY)

## 27) Что такое индексы в БД и для чего они нужны, какие виды индексов существуют?
**Индекс** — это специальная структура данных, которая ускоряет операции поиска в таблице. Можно сравнить с оглавлением в книге или алфавитным указателем.

Для чего нужны индексы?   
- Ускорение поиска (WHERE, JOIN)
- Ускорение сортировки (ORDER BY)
- Обеспечение уникальности (UNIQUE constraints)
- Ускорение группировки (GROUP BY)

Основные виды индексов:
- Первичный индекс (Primary Key Index)
- Уникальный индекс (Unique Index)
- Составной индекс (Composite/Compound Index)
- Полнотекстовый индекс (Full-Text Index)
- SPATIAL (геоиндекс)

## 28) В каких ситуациях индекс хорош, а когда плох?
«Индексируй только то, что читаешь часто, и не индексируй то, что часто изменяешь»

Когда индекс ХОРОШ:
- Частые поиски по конкретному полю (WHERE)
- Внешние ключи и JOIN'ы
- Сортировка и группировка (ORDER BY, GROUP BY)
- Уникальные столбцы (UNIQUE или PRIMARY KEY)
- Столбцы с высокой кардинальностью
- Составные условия поиска

Когда индекс ПЛОХ (или бесполезен):
- Поля с низкой кардинальностью (например, status, gender или is_active)
- Часто обновляемые таблицы (Логи, INSERT, UPDATE или DELETE)
- Маленькие таблицы (Таблица на 100-500 строк)
- Поля, которые никогда не используются в WHERE (Очень большие текстовые поля)
- Слишком много индексов на одной таблице

## 29) ACID, что это такое?
**ACID** — это набор свойств, которые гарантируют надежность и предсказуемость транзакций в базах данных. Это фундаментальная концепция, особенно важная для финансовых приложений, где критически важна целостность данных.
- **Atomicity** (Атомарность) (Принцип: "Все или ничего" — транзакция выполняется либо полностью, либо не выполняется вовсе.)
- **Consistency** (Согласованность) (Принцип: Транзакция переводит базу данных из одного согласованного состояния в другое.)
- **Isolation** (Изолированность) (Принцип: Параллельные транзакции не должны мешать друг другу.)
- **Durability** (Долговечность) (Принцип: Если транзакция завершена (committed), ее результаты гарантированно сохраняются, даже при сбое системы.)

## 30) Какие бывают базы данных, и чем они различаются между собой?
**Реляционные базы данных (SQL)** (MySQL, PostgreSQL, MariaDB, SQLite, MS SQL Server, Oracle.)
- Модель данных - Таблицы, связи
- Масштабирование - Вертикальное
- Сильные стороны - Транзакции, целостность

**Документно-ориентированные (NoSQL)** (MongoDB, CouchDB, Firebase Firestore)
- Модель данных - JSON/BSON/XML-документы
- Масштабирование - Горизонтальное
- Сильные стороны - Гибкость, производительность

**Ключ–значение (Key-Value Stores)** (Redis, Memcached, DynamoDB.)
- Модель данных - Key-Value пары
- Масштабирование - Горизонтальное
- Сильные стороны - Скорость, кэширование

**Графовые базы данных** (Neo4j, OrientDB, ArangoDB.)
- Модель данных - Узлы и связи
- Масштабирование - Горизонтальное
- Сильные стороны - Поиск связей, рекомендации

**Колонночные базы данных** (ClickHouse, Cassandra, HBase.)
- Модель данных - Колонки
- Масштабирование - Горизонтальное
- Сильные стороны - Аналитика, агрегации, большие объемы данных (BigData)

**Поисковые движки** (Elasticsearch, OpenSearch)
- Модель данных - Документы + индекс
- Масштабирование - Горизонтальное
- Сильные стороны - Полнотекстовый поиск

**Временные (Time Series) базы данных** (InfluxDB, TimescaleDB, Prometheus.)

## 31) Clickhouse, какая БД? Реляционная или нет?
**ClickHouse** — не реляционная БД, а колоночная аналитическая система (OLAP-систем — Online Analytical Processing)
- SQL-совместимая (но с ограничениями)
- НЕ реляционная в классическом понимании
- НЕ для OLTP-нагрузок (Online Transaction Processing)
- Быстрые агрегатные функции по колонкам, БД работает на чтение > запись

## 32) В каком виде хранятся данные в PostgreSQL?
Данные в PostgreSQL хранятся в виде строк (Rows), организованных в таблицы (Tables), что соответствует реляционной модели. Однако на физическом уровне (на диске) данные хранятся в виде файлов, состоящих из страниц (Pages).

## 33) Что такое Redis, где используется?
**Redis** — это (in-memory) база данных типа "ключ-значение" с открытым исходным кодом. Название расшифровывается как REmote DIctionary Server.

**Хорошие сценарии**:
- Кэширование (сессии, HTML, данные)
- Очереди (отложенные задачи)
- Счетчики (просмотры, лайки)
- Временные данные (корзины, коды подтверждения)
- Реальное время (чаты, уведомления)

**Плохие сценарии**:
- Большие бинарные данные (файлы, изображения)
- Сложные запросы (нет JOIN, WHERE)
- Данные > доступной RAM (вытеснение старых данных)
- Критически важные данные (риск потери при перезагрузке)

## 34) Какие подтипы нереляционных БД существуют?
Документные БД (Document Stores) 
- Хранение документов в формате JSON/BSON/XML 
- MongoDB/Couchbase

Ключ-Значение (Key-Value Stores) 
- Простой словарь ключ → значение
- Redis/Memcached

Колоночные БД (Column-Family Stores) 
- Данные хранятся по колонкам, а не по строкам 
- ClickHouse/Cassandra

Графовые БД (Graph Databases) 
- Узлы (nodes-сущности) и ребра (edges-связи) 
- Neo4j

Поисковые движки (Search Engines)
- Специализированные БД для полнотекстового поиска
- Elasticsearch/OpenSearch

БД временных рядов (Time-Series Databases)
- Оптимизированы для данных с метками времени
- InfluxDB

## 35) Что такое Explain, в контексте БД?
**EXPLAIN** — это команда в SQL-базах данных, которая показывает план выполнения запроса.
- Оптимизация медленных запросов
- Понимание как работает БД (использует ли запрос индексы, и какие)
- Выявление узких мест
- Проверка использования индексов

## 36) Как используется принцип SRP (SOLID) в Laravel?
Laravel сам реализует SRP во многих местах:
- Form Requests — только валидация.
- Middleware — только фильтрация и проверка запросов.
- Jobs / Listeners — выполняют одну задачу (например, отправку письма).
- Mailables — отвечают только за формирование письма.
- Policies / Gates — отвечают за авторизацию.

## 37) В какой класс лучше вывести проверку данных (валидацию) с контроллера в Laravel?
Для большинства случаев — Form Request.

Альтернативы:
- Service Classes
- Custom Validator
- Traits
- Rules Objects

## 38) Какой принцип SOLID будет использован при разделении данного контроллера?
Основной принцип: SRP (Single Responsibility Principle).

Дополнительно применяются:
- DIP через dependency injection
- OCP через возможность расширения
- LSP через заменяемость сервисов
- ISP через разделенные интерфейсы

## 39) Расскажи про жизненный цикл запроса в Laravel?
**1. Вход в приложение (public/index.php):**
- Загружает автозагрузчик Composer'а
- Создаёт и запускает ядро приложения (App\Http\Kernel)

**2. Создание экземпляра приложения (app.php):**
- Файл bootstrap/app.php создаёт основу фреймворка — контейнер зависимостей (Service Container).

**3. Обработка через HTTP Kernel**

**4. Middleware Pipeline (Запрос проходит через стек middleware):**
  - Глобальные Middleware (Request → TrustProxies → CheckForMaintenanceMode → ValidatePostSize →)
  - Группы Middleware (например, 'web') (→ EncryptCookies → VerifyCsrfToken → ...)

**5. Маршрутизация: Router (Router находит подходящий маршрут)**

**6. Контроллер и обработка**
  - Получает данные от пользователя;
  - Может вызвать модель, сервис, валидацию (FormRequest);

**7. Модели и Eloquent ORM**

**8. Service Providers Загрузка**

**9. Возврат Response:**
  - return response()->json($data);
  - return view('template');
  - return redirect('/home');
  - Middleware обрабатывают response на обратном пути (← AddHeaders ← EncryptCookies ← ...)

**10. Завершение: Termination и HTTP Response клиенту**

## 40) В 10 версии Laravel существовал therm файл за что он отвечал?
- Временный маркер для отслеживания состояния приложения
- Инструмент для "hot reload" в режиме разработки
- Автоматически управляется фреймворком
- Не предназначен для ручного редактирования
- Не должен попадать в репозиторий

## 41) Что такое middleware в Laravel, и какой функционал он выполняет?
**Middleware** (Промежуточное ПО) в Laravel — это механизм, который действует как фильтр, обрабатывая HTTP-запросы, прежде чем они достигнут контроллера, и HTTP-ответы, прежде чем они будут отправлены клиенту.

**Схема** (HTTP Request → Global Middleware → Route Middleware → Controller → Route Middleware → Global Middleware → HTTP Response)

**Использование** (Аутентификация, Защита CSRF, Кэширование, Throttling, CORS, Обслуживание, Локализация, Логирование)

## 42) Что такое события в Laravel, как и где используются?
**События (Events)** в Laravel — это простой и мощный механизм паттерна **Наблюдатель (Observer Pattern)**. Они позволяют регистрировать определённые действия или происшествия в приложении и прикреплять к ним обработчики (Listeners).
- События (Events) — это способ сообщить системе, что что-то произошло.
- Слушатели (Listeners) — это куски кода, которые реагируют на это событие.

**Когда использовать события?**
- Отправка уведомлений
- Обновление связанных данных
- Логирование активности
- Кэширование и инвалидация
- Интеграция с внешними сервисами

## 43) Что такое обсерверы?
**Обсерверы (Observers)** в Laravel — это специальные классы, которые позволяют "наблюдать" за событиями модели Eloquent и реагировать на них. (creating, created, updating, updated, deleting, deleted, restoring, restored)

**Когда использовать обсерверы:**
- Генерация slug
- Удаление файлов при удалении модели
- Логирование изменений
- Отправка уведомлений при создании

## 44) Как в Laravel можно ограничить количество подключений одного пользователя к ip адресу приложения?
Throttle Middleware (Встроенная защита)

Rate Limiting с аутентификацией

Кастомный Rate Limiter

## 45) Как в Laravel реализовываются запросы на сторонние приложения, что для этого применяются?
Фасад HTTP Client Laravel (Guzzle под капотом)

## 46) Что такое Guzzle в чем его удобство, и какую функцию он реализует в PHP?
**Guzzle** — это PHP HTTP-клиент, который упрощает отправку HTTP-запросов и интеграцию с веб-сервисами. Это библиотека, на которой построен HTTP-клиент Laravel.
- Назначение	Выполнение HTTP-запросов
- Реализует	Клиент для REST, SOAP, JSON API и т.д.
- Под капотом	cURL
- Используется в	Laravel (Http), Symfony, WordPress, SDK от AWS и др.
- Уровень	Must-have для любого backend-разработчика

## 47) Можно ли по нему авторизовываться?
Guzzle отлично подходит для авторизации и поддерживает:
- Bearer Tokens (JWT, OAuth)
- OAuth 1.0/2.0 все flow
- Basic/Digest Auth
- API Keys (headers, query params)
- Cookie-based аутентификация
- Кастомные схемы аутентификации

## 48) Какая структура HTTP запроса?
**Start Line (Первая строка)** (GET /api/users HTTP/1.1):
- Метод - GET, POST, PUT, DELETE и т.д.
- URI - путь к ресурсу (/api/users)
- Версия HTTP - HTTP/1.1 или HTTP/2

**Headers (Заголовки)**
- Общие заголовки (Connection, Cache-Control)
- Заголовки запроса (Host, User-Agent, Accept, Accept-Language, Accept-Encoding, Authorization)
- Заголовки содержимого (Content-Type, Content-Length, Content-Encoding)

**Empty Line (Пустая строка)** (разделитель между заголовками и телом)

**Body (Тело запроса)** - опционально

**ПРИМЕР POST запрос с JSON телом:**
```
POST /api/users HTTP/1.1
Host: api.example.com
Content-Type: application/json
Content-Length: 87
Authorization: Bearer token123
User-Agent: MyApp/1.0

{
"name": "Alice Smith",
"email": "alice@example.com",
"password": "securepassword123"
}
```
## 49) В каком элементе запроса хранятся данные по авторизации?
**Authorization Header** (Самый распространенный):
- Bearer Token (JWT, OAuth) (Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...)
- Basic Auth (Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=) - login:password в base64
- Digest Auth (Authorization: Digest username="user", realm="example", nonce="abc123")
- API Key (иногда) (Authorization: APIKey your-api-key-here)

**Custom Headers** (Кастомные заголовки) (X-API-Key, X-API-Token, X-Auth-Token, API-Key)

**Cookies (Для сессий**) (Cookie: session_id=abc123def456; auth_token=xyz789;)

**Query Parameters (В URL)** (GET /api/data?api_key=your_key_123&token=abc123)

**Body Data** (Form-based аутентификация)

## 50) Что такое Bearer?
**Bearer (от англ. "носитель")** — это тип аутентификации, где наличие токена дает право доступа к защищенным ресурсам. Тот, кто "несет" (has bearer) токен, получает доступ.

**Authorization: Bearer <token>**
- Схема аутентификации для передачи токенов
- Простой стандарт - Authorization: Bearer <token>
- Универсальный - работает с JWT, OAuth, кастомными токенами
- Без состояния (stateless) - серверу не нужно хранить сессию
- Стандарт де-факто для REST API и мобильных приложений

## 51) Что такое Eloquent ORM, для чего используется, какие типы связи есть?
**Eloquent ORM (Object-Relational Mapping)** — это реализация паттерна Active Record в Laravel, который позволяет работать с базой данных используя объектно-ориентированный синтаксис вместо SQL запросов.

**Для чего используется Eloquent?**
- Упрощение работы с БД
- Объектно-ориентированный подход
- Безопасность от SQL-инъекций

**Типы связей в Eloquent:**
- One To One (Один к одному) (User hasOne Profile, Profile belongsTo User)
- One To Many (Один ко многим) (User hasMany Post, Post belongsTo User)
- Many To Many (Многие ко многим) (Post belongsToMany Tag, Tag belongsToMany Post) PIVOT table post_tag
- Has Many Through (Имеет много через) (Country hasManyThrough Post, User)
- Polymorphic Relations (Полиморфные связи) (Comment morphTo, Post morphMany Comment, Video morphMany Comment)
- Many To Many Polymorphic (Полиморфные многие ко многим) (Tag morphedByMany Post, Tag morphedByMany Video, Post morphToMany Tag, Video  morphToMany Tag)

## 52) Что такое SQL инъекции?
**SQL инъекция** — это атака, при которой злоумышленник внедряет вредоносный SQL-код в запросы к базе данных, чтобы получить несанкционированный доступ к данным или выполнить несанкционированные операции.

`(' OR '1'='1' --)`

**Защита от SQL инъекций:**
- Подготовленные выражения (Prepared Statements)
- Экранирование данных

## 53) ORM защищает от SQL инъекций? Или все равно можно получить несанкционированый доступ?
**ЗАЩИЩЕНО автоматически:**
- Все методы Eloquent (where(), find(), create() etc.)
- Query Builder с биндингом параметров
- PDO prepared statements

**ТРЕБУЕТ осторожности:**
- DB::raw(), whereRaw(), selectRaw()
- DB::statement()
- Динамические имена таблиц/колонок (Нужно делать белые списки для ORDER BY)

**НЕ ЗАЩИЩАЕТ от:**
- Logic flaws (логические ошибки приложения)
- Mass assignment (если не настроены $fillable/$guarded)
- NoSQL injection (для нереляционных БД)
- XSS, CSRF, etc. (другие типы атак)

## 54) Что такое Job в Laravel, для чего они нужны, как они работают, кто их запускает?
**Job** — это класс, который представляет собой задачу, которая может быть выполнена в фоновом режиме, отдельно от основного HTTP-запроса.

**Для чего нужны Jobs?**
- Долгие операции (обработка видео)
- Отправка email
- Обработка данных (Генерация отчетов, Синхронизация с внешними API, Обработка изображений)

**Как работают Jobs?**
- Диспатч: ProcessPayment::dispatch($user, 100)
- Сериализация: Job преобразуется в JSON и сохраняется в очередь
- Хранение: Данные хранятся в Redis/Database/SQS
- Обработка: Worker забирает задачу из очереди
- Выполнение: Вызывается метод handle()
- Завершение: Job удаляется из очереди

**Кто запускает Jobs?**

Jobs не запускаются самим PHP-скриптом, который обрабатывает HTTP-запрос. Их запускают Worker-процессы (рабочие процессы).
- Worker (Рабочий процесс): Это процесс, запущенный в фоновом режиме на сервере, который постоянно слушает очередь.
- Команда Artisan: Worker запускается с помощью команды Artisan Queue Worker (php artisan queue:work)
- Менеджеры процессов: На продакшене queue:work запускается и управляется специальными менеджерами процессов (например, Supervisor), которые гарантируют, что Worker всегда активен, перезапускается при сбоях и запускается при старте сервера.

## 55) Какой инструмент в Laravel управляет этими очередями?
**Разработка**: queue:listen или queue:work

**Продакшен**: Horizon (Redis) + Supervisor (Unix)

**Администрирование**: Artisan commands (queue:failed, queue:retry)

## 56) Что такое Supervisor?
**Supervisor** — это системный демон для Unix-систем, который управляет процессами и гарантирует их постоянную работу.
- Запускает процессы и следит за их работой
- Автоматически перезапускает упавшие процессы
- Управляет несколькими процессами одновременно
- Предоставляет веб-интерфейс для мониторинга

## 57) Сколько Worker можно запустить на 1 задачу? Для чего это делается?
На одну задачу (Job) → 1 Worker

Но на тип задач можно запустить много Workers для:
- Параллелизм - 8 workers вместо 1 (В 8 раз быстрее обработка)
- Пиковые нагрузки - 50 workers на Black Friday (Без задержек для пользователей)
- Приоритизация - 10 workers для платежей, 2 для email (Важные задачи обрабатываются первыми)
- Балансировка - Разные workers для CPU/I/O задач (Оптимальное использование ресурсов)

## 58) Где хранятся настройки Laravel?
Файлы конфигурации (config/)

Файлы переменных окружения (.env)

Файлы окружения по environment (опционально) (.env.local, .env.staging, .env.production)

## 59) Какие минусы могут возникнуть при использовании обсервера в контроллере? Например в Post при привязке тегов?
- Нарушение Single Responsibility Principle (SRP)
- Сложность тестирования
- Неявные побочные эффекты
- Проблемы с транзакциями
- Сложность отладки

Правильная альтернатива: Service (Action) Class

## 60) Если после изменения роутинга, перестал работать проект, какие команды рекомендуется использовать в Laravel?
Приоритетная последовательность:
1. `php artisan route:clear`          - Самое важное!
2. `php artisan route:list`           - Проверить роуты
3. `composer dump-autoload`          - Перезагрузить классы
4. `php artisan cache:clear`         - Очистить кэш данных
5. `php artisan config:clear`        - Очистить кэш конфигов
   
Если не помогло:
6. `php artisan optimize:clear`      - Полная очистка
7. `php artisan package:discover`    - Пере discover пакетов
8. `php artisan route:cache`         - Кэшировать заново

## 61) Вопрос по гиту, предположим начинаем свою ветку переносить в мастер, и появился конфликт, какие наши первые действия?
- `git status` — посмотреть что случилось
- `git diff` — проанализировать конфликты
- Редактировать файлы — убрать `<<<<<<<, =======, >>>>>>>`
- `git add .` — добавить исправленные файлы
- `git commit` — завершить слияние
- `git push` — отправить изменения

## 62) Что такое чери пик?
**Cherry-pick** — это операция "выборочного копирования" конкретных коммитов между ветками.

**Когда использовать cherry-pick:**
- Срочные фиксы из development в production
- Backport исправлений между версиями
- Восстановление потерянных коммитов
- Частичный перенос фич

**Когда НЕ использовать cherry-pick:**
- Для регулярного кода между ветками
- Когда можно использовать merge/rebase
- Для больших feature-веток

## 63) Чем отличается git merge от git rebase?
`git merge` объединяет ветки, создавая новый merge-коммит и сохраняя историю ветвления.

`git rebase` переписывает историю, «перенося» коммиты одной ветки поверх другой,
делая историю линейной.

В рабочих ветках часто используют `rebase` для чистой истории,
а в общих ветках — `merge`, чтобы избежать конфликтов истории.

## 64) Как работает команда git reset?
`git reset` перемещает указатель ветки (HEAD) на другой коммит и опционально обновляет рабочую директорию и индекс.
1. `--soft` — Только перемещает HEAD
2. `--mixed` (по умолчанию) — + Обновляет индекс
3. `--hard` — + Обновляет рабочую директорию

## 65) Что такое моковое тестирование, и область его применения?
**Моковое тестирование (Mock Testing)** - это техника тестирования, где мы создаем "подставные" объекты вместо реальных зависимостей.
```php
// Пример на PHPUnit
public function testOrderProcessing() {
    // 1. Создаем "куклу" банка
    $mockBank = $this->createMock(BankGateway::class);

    // 2. Настраиваем её: "Если вызовут charge, верни true"
    $mockBank->method('charge')->willReturn(true);

    // 3. Передаем куклу в наш сервис вместо настоящего банка
    $service = new OrderService($mockBank);

    // 4. Проверяем, что сервис работает
    $this->assertTrue($service->processOrder(100));
}
```
### Области применения:
1. **Внешние сервисы** (платежи, почта, API)
2. **Базы данных** - чтобы не зависеть от реальных данных
3. **Сложные вычисления** - когда нужно тестировать логику, а не производительность
4. **Еще не реализованный функционал** - можно тестировать свою часть кода, пока коллеги делают смежные модули

### Когда НЕ использовать моки:
1. Тестирование конечного пользовательского сценария
2. Проверка интеграции с реальными сервисами
3. Когда проще использовать реальный объект

## 65) Какая проблема может возникнуть с моками при тестировании интерфейсов?
Главная проблема моков при тестировании интерфейсов называется **«Рассинхрон» (Drift)** или **«Ложно-позитивные тесты»**.

### Как это лечится?
**Интеграционные тесты.** Хотя бы один тест должен проверять работу с реальным классом (или базой/сервисом), чтобы убедиться, что все части системы всё еще понимают друг друга правильно.

## 66) Паттерны проектирования, на какие категории делятся, и какие и где активно используются?
**Паттерны проектирования** — это типовые решения частых проблем в проектировании ПО. Они делятся на **3** основные категории:

### Порождающие (Creational) - создание объектов
**Суть:** Решают проблему «Как создать объект, не используя везде `new ClassName()`».
**Зачем:** Чтобы код не зависел от конкретных классов.

#### Singleton (Одиночка)
**Суть**: Класс, у которого может быть только **ОДИН** экземпляр на всё приложение. Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа. Но считается анти-паттерном, так как создает скрытые зависимости и сложно тестируется
```php
// В Laravel - сервис-контейнер часто возвращает singleton'ы
$logger = app(Logger::class); // Всегда один экземпляр
```

#### Factory Method (Фабричный метод)
**Суть**: Есть интерфейс для создания объекта, но какой именно класс создать — решают наследники.
```php
// В Laravel - фабрики моделей
User::factory()->create();
```

#### Builder (Строитель)
**Суть**: Позволяет создавать сложные объекты пошагово.
```php
// SQL Query Builder в Laravel!
DB::table('users')->where('id', 1)->orderBy('name')->get();
```

#### Abstract Factory - создает семейства связанных объектов

#### Prototype - клонирование существующих объектов

### Структурные (Structural) - композиция объектов
**Суть**: Решают проблему «Как собрать классы и объекты в более крупные структуры».
**Зачем**: Чтобы старое работало с новым и не ломалось.

### Adapter (Адаптер)
**Суть**: «**Переходник**». Позволяет объектам с несовместимыми интерфейсами работать вместе.
```php
// В Laravel - адаптеры для файловых систем
Storage::disk('s3')->put('file.jpg', $contents);
```

#### Facade (Фасад)
**Суть**: Простой интерфейс к сложной системе классов.
```php
// Фасады Laravel
Cache::get('key');
DB::table('users')->get();
```

#### Decorator (Декоратор/Обертка)
**Суть**: Динамически добавляет объекту новые обязанности (оборачивает его), не меняя сам класс.
```php
// Middleware в Laravel - классический декоратор
Route::middleware(['auth', 'admin'])->get(...);
```

#### Composite - древовидные структуры объектов

#### Proxy - контроль доступа к объекту

### Поведенческие (Behavioral)
**Суть**: Решают проблему «Как объекты общаются друг с другом и распределяют обязанности».

#### Observer (Наблюдатель)
**Суть**: Один объект меняется, все подписчики узнают об этом автоматически.
```php
// События в Laravel
UserCreated::dispatch($user);
```

#### Strategy (Стратегия)
**Суть**: Мы выносим набор алгоритмов в отдельные классы и делаем их взаимозаменяемыми.
**Пример**: Оплата.
У тебя есть интерфейс `PaymentInterface` с методом `pay()`.
Есть стратегии: `PayPalStrategy`, `StripeStrategy`, `CashStrategy`
```php
// Разные стратегии кэширования в Laravel
config('cache.default'); // redis, file, database
```

#### Iterator (Итератор)
**Суть**: Способ последовательно обходить элементы сложного объекта (коллекции).

#### Command - инкапсуляция запросов как объектов
```php
// Artisan команды
php artisan make:controller TestController
```

## 67) Движки БД MYSQL, какие есть, в чем отличие, на что нужно обращать внимание
**Движки БД (Storage Engines)** - это компоненты СУБД, отвечающие за хранение, обработку и извлечение данных. 

В мире MySQL (самой популярной БД для PHP) движок (Storage Engine) — это модуль, который отвечает за то, как именно данные хранятся на диске, как они читаются и обновляются.

### MyISAM (устаревший, но встречается)
Раньше был дефолтным (до версии 5.5). Сейчас считается устаревшим.
* **Главная фишка**: Очень быстрый на ЧТЕНИЕ.
* **Главный минус**: Блокировка всей таблицы (Table-level locking).
* **Нет транзакций**: Если во время записи выключат свет — данные могут побиться.
* **Нет внешних ключей (Foreign Keys)**: База не следит за тем, чтобы у Заказа обязательно был существующий Пользователь.
* **FULLTEXT-индексы**

### InnoDB (стандарт с MySQL 5.5+)
Используется по умолчанию во всех современных проектах
* **Главная фишка**: Транзакции (ACID).
* **Блокировка строк** (Row-level locking).
* **Надежность**: Умеет восстанавливаться после сбоев.
* **Внешние ключи**: Гарантирует целостность связей.
* Кэширование данных и индексов

## 68) Блокировки в БД, оптимистичные и пессимистичные, что это и что нужно знать?
**Блокировки в БД** - это механизмы контроля доступа к данным при параллельных операциях.

### Пессимистичные блокировки (Pessimistic Locking)
**Философия**: "Лучше перебдеть" - предполагаем, что конфликты будут часто, поэтому блокируем данные заранее.
```sql
-- Явная блокировка строки на время транзакции
BEGIN;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
-- Другие транзакции ждут, пока мы не сделаем COMMIT/ROLLBACK
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;
```
```php
DB::transaction(function () {
    $account = Account::where('id', 1)->lockForUpdate()->first();
    $account->balance -= 100;
    $account->save();
});
```
**Где использовать:**
* Банковские транзакции
* Бронирование мест
* Системы с высокой конкуренцией за данные

**Проблемы:**
* Могут возникать взаимоблокировки (deadlocks)
* Снижают производительность при высокой нагрузке

### Оптимистичные блокировки (Optimistic Locking)
**Философия**: "Конфликты редки" - разрешаем всем читать данные, но проверяем при записи, не изменились ли они.
```sql
ALTER TABLE products ADD COLUMN version INT DEFAULT 0;
```
```php
// В коде проверяем версию
$product = Product::find(1);
$product->name = 'New Name';
$product->price = 99.99;

// Проверяем, что никто не изменил запись пока мы работали
$affected = Product::where('id', 1)
              ->where('version', $product->version)
              ->update([
                  'name' => $product->name,
                  'price' => $product->price,
                  'version' => $product->version + 1
              ]);

if ($affected === 0) {
    throw new OptimisticLockException('Данные были изменены другим пользователем');
}
```
**Где использовать:** Редактирование профиля, админка, комментарии. Там, где столкновения редки.

**Проблемы:** Если конфликт случился, пользователю вылетит ошибка, и ему придется вводить данные заново (или нам надо писать код для повторной попытки).

## 69) Что такое Deadlock и как его избежать?
**Deadlock (Взаимоблокировка)** - это ситуация, когда две или более транзакций блокируют друг друга, каждая ожидает ресурс, занятый другой.

### Способы избежать deadlock:
#### Единый порядок блокировки
Всегда блокируйте ресурсы в одинаковом порядке:
```php
// Всегда блокируем по возрастанию ID
DB::transaction(function () {
    $accounts = Account::whereIn('id', [1, 2])
                 ->orderBy('id')
                 ->lockForUpdate()
                 ->get();
});
```
#### Короткие транзакции
```php
// ❌ Долгая транзакция = выше риск deadlock
DB::transaction(function () {
    $account = Account::lockForUpdate()->find(1);
    // ... сложная бизнес-логика ...
    // ... вызовы внешних API ...
    $account->save();
});

// ✅ Короткая транзакция
$account = Account::find(1);
// ... вся логика ВНЕ транзакции ...
DB::transaction(function () use ($account) {
    $account->lockForUpdate()->save();
});
```
#### Использование таймаутов/retry
```php
// В config/database.php
'mysql' => [
    'options' => [
        PDO::ATTR_TIMEOUT => 10,
    ]
];

// Или на уровне транзакции
DB::transaction(function () {
    // ...
}, 3); // Количество попыток при deadlock
```
#### Избегание ненужных блокировок
```php
// ❌ Лишняя блокировка
$user = User::lockForUpdate()->find(1); // Зачем блокировка для чтения?

// ✅ Чтение без блокировки  
$user = User::find(1);

// ✅ Блокировка только при реальной необходимости
DB::transaction(function () {
    $user = User::lockForUpdate()->find(1);
    $user->balance += 100;
    $user->save();
});
```
#### Использование пессимистичных блокировок с умом
```php
// Вместо lockForUpdate() на всю таблицу
DB::transaction(function () {
    // Блокируем только нужные строки
    $accounts = Account::whereIn('id', [1, 2])
                 ->lockForUpdate()
                 ->get();
});
```

## 70) Уровни изоляции БД
**Уровни изоляции БД** - это настройки, определяющие, насколько транзакции "видят" изменения друг друга. Чем строже уровень, тем больше согласованность данных, но ниже производительность.

### 4 стандартных уровня изоляции (от слабого к строгому):
#### 1 - Read Uncommitted (Чтение незафиксированных данных)
**Что позволяет:** Читать данные, которые другие транзакции еще не закоммитили.
**Проблемы:** Грязное чтение (Dirty Read) - видите "грязные" данные, которые могут быть откатаны
```sql
-- Транзакция 1
BEGIN;
UPDATE users SET balance = 1000 WHERE id = 1; -- Не коммитил

-- Транзакция 2 (Read Uncommitted)
SELECT balance FROM users WHERE id = 1; -- Увидит 1000!
-- Если транзакция 1 сделает ROLLBACK - данные недействительны
```

#### 2 - Read Committed (Чтение зафиксированных данных)
**Что позволяет:** Видеть только закоммиченные данные.
**Проблемы:** Неповторяемое чтение (Non-repeatable Read) - данные меняются между чтениями
```sql
-- Транзакция 1
BEGIN;
SELECT balance FROM users WHERE id = 1; -- Вернуло 100

-- Транзакция 2
UPDATE users SET balance = 200 WHERE id = 1;
COMMIT;

-- Транзакция 1
SELECT balance FROM users WHERE id = 1; -- Теперь 200! Данные изменились
```

#### 3 - Repeatable Read (Повторяемое чтение)
**Что позволяет:** Гарантирует, что данные не меняются в рамках одной транзакции.
**Проблемы:** Фантомное чтение (Phantom Read) - появляются новые строки
```sql
-- Транзакция 1
BEGIN;
SELECT COUNT(*) FROM users WHERE age > 30; -- Вернуло 5

-- Транзакция 2  
INSERT INTO users (name, age) VALUES ('John', 35);
COMMIT;

-- Транзакция 1
SELECT COUNT(*) FROM users WHERE age > 30; -- Теперь 6! Появилась новая строка
```

#### 4 - Serializable (Сериализуемый)
**Что позволяет:** Полная изоляция - транзакции выполняются последовательно.
**Преимущества:** Нет аномалий
**Недостатки:** Низкая производительность

### Уровни изоляции в разных СУБД:
MySQL (InnoDB): По умолчанию: REPEATABLE READ
PostgreSQL: По умолчанию: READ COMMITTED

### Как выбрать уровень изоляции:
1. **Read Uncommitted**	Аналитика, отчеты (где не важна точность)	🟢🟢🟢
2. **Read Committed**	Большинство веб-приложений 🟢🟢🟡
3. **Repeatable Read**	Финансовые операции, бронирования 🟢🟡🔴
4. **Serializable**	Критически важные операции 🔴🔴🔴

## 71) Оператор DISTINCT в SQL - что это и зачем применять?
**Оператор DISTINCT** - это ключевое слово в SQL, которое убирает дублирующиеся строки из результата запроса.

### Синтаксис и варианты использования:
```sql
-- Уникальные категории товаров
SELECT DISTINCT category FROM products;

-- Уникальные комбинации категория+поставщик
SELECT DISTINCT category, supplier FROM products;

-- Количество уникальных категорий
SELECT COUNT(DISTINCT category) FROM products;
```

### Важные особенности DISTINCT:
#### Производительность
```sql
-- DISTINCT требует сортировки и сравнения данных
-- На больших таблицах может быть медленным
SELECT DISTINCT name FROM users; -- Медленно на 1M записей

-- Альтернатива - использовать GROUP BY
SELECT name FROM users GROUP BY name; -- Иногда быстрее
```

#### Работа с NULL значениями
```sql
-- DISTINCT считает все NULL одинаковыми
SELECT DISTINCT email FROM users;
-- Все NULL значения будут свернуты в одну строку
```

#### С агрегатными функциями
```sql
-- Правильно: DISTINCT внутри COUNT
SELECT COUNT(DISTINCT category) FROM products; -- 3

-- Неправильно: DISTINCT снаружи
SELECT DISTINCT COUNT(category) FROM products; -- Не то, что ожидалось
```

### Когда использовать DISTINCT:

✅ **Подходящие случаи:**
* Получение уникальных значений для выпадающих списков
* Аналитика и отчеты (уникальные пользователи, категории)
* Поиск дубликатов данных

❌ **Когда НЕ использовать:**
* Вместо правильной нормализации БД
* На очень больших таблицах без индексов
* Когда нужны все данные (например, для пагинации)

# Отдельный раздел, который нужно будет объединить с основным и разбить на подразделы
## Какой основной протокол интернета?
Семейство протоколов **TCP/IP** (Transmission Control Protocol / Internet Protocol). Это Транспортный и Сетевой уровни (Layer 4 и 3).

**HTTP** — это Прикладной уровень (Layer 7 по модели OSI). Это язык, на котором браузер говорит с сервером. Для веба.

## Какие есть версии HTTP протокола? Какие их отличия?
**HTTP/1.1** — классический, текстовый, последовательные запросы, существует keep-alive, но всё равно head-of-line blocking.

**HTTP/2** — бинарный, мультиплексирование в одном соединении, сжатие заголовков, быстрее под нагрузкой.

**HTTP/3** — работает поверх QUIC/UDP, лучше справляется с потерями пакетов, самый быстрый, уже активно внедряется.

### Ключевые отличия между версиями HTTP:
#### HTTP/1.1 vs HTTP/2:
* **Бинарный протокол:** HTTP/2 использует бинарные фреймы вместо текста, что ускоряет парсинг
* **Мультиплексирование:** Одно TCP-соединение для параллельных запросов (решает проблему head-of-line blocking)
* **Сжатие заголовков:** HPACK уменьшает избыточность заголовков
* **Server Push:** Сервер может отправлять ресурсы до запроса клиента
* **Приоритизация:** Клиент может указать приоритеты запросов

#### HTTP/2 vs HTTP/3:
* **Транспортный протокол:** HTTP/3 использует QUIC поверх UDP вместо TCP
* **Улучшенное мультиплексирование:** Решает проблему head-of-line blocking на транспортном уровне
* **Быстрое установление соединения:** 0-RTT handshake в некоторых сценариях

### Какой протокол под HTTP?
#### Классика (HTTP/1.1 и HTTP/2):
Работают поверх **TCP** (Transmission Control Protocol).

**Почему**: TCP гарантирует, что данные дойдут **целыми и в правильном порядке**. Если пакетик потерялся по дороге, TCP его перешлет. Для веба это критично (мы не хотим видеть пол-картинки).

#### Новая школа (HTTP/3):
Работает поверх **UDP** (User Datagram Protocol) через прослойку QUIC.

**Почему**: TCP слишком «тяжелый» и медленный на старте (долгое рукопожатие). UDP — это «выстрелил и забыл», он супер-быстрый. Google придумал протокол QUIC, который берет быстрый UDP и добавляет ему надежность (как у TCP), но без тормозов.

## Директива DECLARE в контексте PHP, что это и зачем?
`declare` — это конструкция, которая управляет поведением PHP-интерпретатора на уровне файла или блока.

### declare(strict_types=1)
Чаще всего используется `declare(strict_types=1)`, чтобы включить строгую типизацию для входных параметров и возвращаемых значений.

Заставляет PHP не преобразовывать типы автоматически. Если функция ждет int, а ты передал строку "5", PHP выбросит ошибку TypeError (вместо того чтобы молча превратить строку в число).

Ещё есть режимы типа `ticks` и `encoding`, но они используются редко.

### declare(ticks=1);
**Зачем**: Говорит PHP: "Каждую 1 операцию (или N операций) проверяй, не пришел ли сигнал от системы".

**Где применяется**: При работе с **асинхронными сигналами** (PCNTL). Например, чтобы скрипт можно было корректно остановить командой kill или Ctrl+C в консоли, или для обработки очередей (RabbitMQ воркеров).

### declare(encoding='...');
Используется для указания кодировки скрипта. Сейчас почти не нужно, так как везде UTF-8.

### Область действия DECLARE в PHP:
**Файловая область видимости:**
```php
// Действует ТОЛЬКО на текущий файл
declare(strict_types=1);

// Если подключаются другие файлы - на них НЕ распространяется
require 'other_file.php';
```

**Блочная область видимости:**
```php
// Действует ТОЛЬКО на блок кода в фигурных скобках
declare(strict_types=1) {
    $a = function(int $x): int { return $x; };
    // Здесь strict_types=1
}
// Здесь уже НЕ действует strict_types=1
```

**Не распространяется на:**
* Подключаемые файлы (include/require)
* Функции и классы из других файлов
* Вызовы извне файла

## Директивы REQUIRE/INCLUDE
`require` и `include` оба подключают внешний файл и исполняют его код.

### Основные различия:
1. **При отсутствии файла:**
* `require` - фатальная ошибка **(E_COMPILE_ERROR)**, выполнение останавливается
* `include` - предупреждение **(E_WARNING)**, выполнение продолжается

2. **Практическое применение:**
* `require` - для обязательных файлов (настройки, основные классы)* 
* `include` - для опциональных блоков (шаблоны, виджеты)

3. **Вариации:**
* `require_once`/`include_once` - гарантируют однократное подключение файла, чтобы избежать переопределения классов или функций

## Файлы Composer - composer.json/composer.lock
**Composer использует два файла:**
— `composer.json` описывает требования — какие пакеты и в каких диапазонах версий нужны проекту. (например, ^8.0).
— `composer.lock` фиксирует точные версии всех установленных библиотек и их зависимостей. (например 8.1.2)

Это нужно для того, чтобы любой разработчик и любой сервер получили идентичную версию окружения. Без lock-файла Composer мог бы подтянуть более свежие версии, что приводит к разному поведению на проде и у разработчиков. 

`composer.lock` Создается автоматически при `composer install` или `composer update`

## Позднее статическое связывание (Late Static Binding)
**Позднее статическое связывание** — это механизм, который позволяет статическим вызовам в наследуемых классах использовать тот класс, из которого выполняется вызов. В PHP это реализовано через ключевое слово `static`.

В отличие от `self`, который всегда ссылается на класс, где метод объявлен, `static` использует реальный класс вызова.

Это важно для корректной работы наследования, особенно в шаблонных методах, фабриках и статических конструкторах.

**Ключевые моменты:**
`self` - привязка на этапе компиляции (к классу где написан)
`static` - привязка на этапе выполнения (к классу откуда вызван)

```php
class Car
{
    public static function model()
    {
        return 'Просто машина';
    }

    public static function getEarly()
    {
        // SELF: Смотрит на класс, где написана эта строчка
        return self::model();
    }

    public static function getLate()
    {
        // STATIC: Смотрит на класс, который реально вызвал метод
        return static::model();
    }
}

class BMW extends Car
{
    public static function model()
    {
        return 'X5';
    }
}

// ВЫЗЫВАЕМ:
echo BMW::getEarly(); // Выведет: "Просто машина" (SELF остался в родителе)
echo BMW::getLate();  // Выведет: "X5" (STATIC понял, что вызвали через BMW)
```

## Механизм передачи данных в PHP. Copy-on-write
В PHP все передается по значению, но с важными нюансами:
1. **Простые типы (int, string, bool, array)** - передаются по значению с **copy-on-write**
2. **Объекты** - передается **указатель** на объект **(object handle)**, но сам механизм передачи - по значению

**Copy-on-write (копирование при записи)** - это оптимизация:
* При присваивании переменной новой переменной данные не копируются физически
* Обе переменные ссылаются на одни данные в памяти
* Копирование происходит только при изменении одной из переменных

```php
$a = 'строка'; // выделена память
$b = $a;       // память НЕ копируется, обе переменные ссылаются на одни данные
$b = 'новая';  // ТОЛЬКО сейчас создается копия в памяти

$obj1 = new MyClass(); // создан объект
$obj2 = $obj1;         // передан указатель на тот же объект
$obj2->property = 1;   // изменяется исходный объект
```
## PSR (PHP Standard Recommendations)
**PSR (PHP Standard Recommendations)** - это стандарты, разрабатываемые **PHP-FIG (PHP Framework Interop Group)** - сообществом представителей основных PHP-фреймворков

### Основные PSR:
* PSR-1, PSR-12 - стандарты кодирования
* PSR-3 - Logger interface
* PSR-4 - современный стандарт автозагрузки (заменил PSR-0)
* PSR-7 - HTTP message interfaces
* PSR-11 - Container interface

#### PSR-4
**Определяет:**
* Соответствие неймспейсов структуре директорий
* Правила автозагрузки классов
* Используется в Composer по умолчанию

**Где используется:**
* Composer (автозагрузка PSR-4)
* Все современные фреймворки (Laravel, Symfony и т.д.)
* Большинство библиотек на Packagist

## SOLID
**SOLID** - это принципы объектно-ориентированного проектирования

### Single Responsibility Principle (Принцип единой ответственности)
**Класс должен иметь только одну причину для изменения.**

Что это значит на практике:
* Каждый класс решает только одну задачу
* Изменения в одной бизнес-логике не должны затрагивать другие
* Код становится более тестируемым и поддерживаемым

**Пример нарушения:**
```php
class OrderProcessor {
    public function process(Order $order) {
        // Валидация заказа
        // Расчет стоимости
        // Сохранение в БД
        // Отправка email
        // Генерация PDF-счета
    }
}
```

**Пример соблюдения:**
```php
class OrderValidator { /* только валидация */ }
class PriceCalculator { /* только расчеты */ }
class OrderRepository { /* только работа с БД */ }
class EmailService { /* только отправка писем */ }
```

**Ключевой критерий:** Если вы можете описать работу класса без использования союза **"и"** - он вероятно соблюдает SRP

### Open-Closed Principle (Принцип Открытости/Закрытости)
**Кассы должны быть:**
* Открыты для расширения - можно добавлять новое поведение
* Закрыты для модификации - не изменять существующий код

```php
// НЕПРАВИЛЬНО - нарушает OCP
class PaymentProcessor {
    public function process($paymentType, $amount) {
        if ($paymentType === 'credit_card') {
            // обработка карты
        } elseif ($paymentType === 'paypal') {
            // обработка PayPal
        }
        // Добавление нового типа требует изменения класса!
    }
}

// ПРАВИЛЬНО - соблюдает OCP
interface PaymentMethod {
    public function process($amount);
}

class CreditCardPayment implements PaymentMethod {
    public function process($amount) { /* ... */ }
}

class PayPalPayment implements PaymentMethod {
    public function process($amount) { /* ... */ }
}

class PaymentProcessor {
    public function process(PaymentMethod $payment, $amount) {
        $payment->process($amount);
        // Новый тип платежа - новый класс, этот код не меняется
    }
}
```
**Ключевые моменты:**
* OCP достигается через интерфейсы и полиморфизм, а не только наследование
* Новый функционал добавляется созданием новых классов, а не изменением существующих
* Это основа многих паттернов (Стратегия, Декоратор и др.)

### Liskov Substitution Principle
### Interface Segregation Principle
### Dependency Inversion Principle

## REST API
**Разница хорошего от плохого примера**
### Хороший REST API:
* **Использует правильные HTTP-методы:** GET (чтение), POST (создание), PUT (полное обновление), PATCH (частичное обновление), DELETE (удаление)
* **Соблюдает идемпотентность:** GET, PUT, DELETE - идемпотентны; POST, PATCH - нет
* **Возвращает корректные HTTP-статусы:** 200, 201, 400, 401, 404, 422, 500
* **Имеет согласованную структуру URL:** /api/v1/users, /api/v1/users/{id}
* **Использует версионирование API**

### Плохой REST API:
```php
// ПЛОХО: Использует GET для изменения данных
GET /api/delete-user?id=1

// ПЛОХО: Всегда возвращает 200, даже при ошибках
{"status": 200, "error": "User not found"}

// ПЛОХО: Действия в URL вместо использования методов
POST /api/create-user
POST /api/update-user
```

В RESTful API методы HTTP должны быть направлены на ресурсы (сущности), а действия определяются HTTP-методом.

**Правильно:**
```
GET    /api/users     - получить список пользователей
POST   /api/users     - создать пользователя
GET    /api/users/1   - получить пользователя
PUT    /api/users/1   - обновить пользователя
DELETE /api/users/1   - удалить пользователя
```

**Неправильно:**
```
GET /api/get-users
GET /api/create-user?name=John
GET /api/delete-user?id=1
```

## CORS (Cross-Origin Resource Sharing)
**CORS (Cross-Origin Resource Sharing)** - это механизм безопасности браузера, который контролирует доступ к ресурсам на разных доменах.

### Проблема, которую решает:
* Браузеры по умолчанию запрещают JavaScript-запросы к API на другом домене (Same-Origin Policy)
* Это защищает пользователей от атак (например, CSRF)
* Но это же мешает работе SPA-приложений, где фронтенд и бэкенд на разных доменах

### Как работает CORS:
1. Браузер отправляет preflight-запрос (OPTIONS) перед основным запросом
2. Сервер отвечает заголовками, указывающими разрешенные:
* `Access-Control-Allow-Origin` - разрешенные домены
* `Access-Control-Allow-Methods` - разрешенные HTTP-методы
* `Access-Control-Allow-Headers` - разрешенные заголовки

**Пример в Laravel:**
```php
// В middleware Cors.php
return $next($request)
    ->header('Access-Control-Allow-Origin', 'https://frontend.com')
    ->header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE')
    ->header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
```

**Практическое значение:**
* Без правильной настройки CORS фронтенд не сможет работать с вашим API
* Нужно явно разрешать только доверенные домены
* В разработке можно временно разрешать все домены `(*)`, но в production это опасно

## Тестирование
### Unit (Модульные) тесты
* **Что тестируем:** Один класс / Один метод в вакууме (сервисы, валидаторы)
* **Зависимости:** Мокаем **ВСЕ** внешние зависимости (БД, API, другие классы)
* **БД:** Нет.
* **Внешние API:** Нет (мокаем)
* **Цель:** Проверить логику в чистом виде
* **Инструмент:** `PHPUnit`, `Mockery`.
* **Пример:** Тестируем калькулятор зарплаты. Нам не нужна база данных, чтобы проверить, что 100 + 20% = 120.

```php
// Unit-тест сервиса
public function test_calculate_total()
{
    $service = new OrderService();
    $result = $service->calculateTotal([100, 200]);
    $this->assertEquals(300, $result);
}
```

### Integration (Интеграционные) тесты
* **Что тестируем:** Взаимодействие 2+ компонентов (Сервис + Репозиторий + БД)
* **Зависимости:** Мокаем только ВНЕШНИЕ сервисы (платежные шлюзы, почта)
* **БД:** Да (реальная, но тестовая, SQLite или отдельная MySQL).
* **Внешние API:** НЕТ! (Мы их подменяем/мокаем).
* **Цель:** Проверить, что компоненты правильно работают вместе
* **Инструмент:** `Laravel Feature Tests` (`$this->get('/api/posts')`), `Symfony WebTestCase`.

**Конкретный пример интеграционного теста:**
**Сервис `PaymentProcessor,` который:**
* Сохраняет платеж в БД через репозиторий
* Отправляет запрос во внешний платежный шлюз
* Обновляет статус заказа

```php
class PaymentProcessorTest extends TestCase
{
    public function test_process_payment()
    {
        // Мокаем внешний сервис
        $gatewayMock = Mockery::mock(PaymentGateway::class);
        $gatewayMock->shouldReceive('charge')
            ->once()
            ->andReturn(['status' => 'success']);
        
        // Используем реальную БД (SQLite в памяти)
        $processor = new PaymentProcessor($gatewayMock);
        $result = $processor->process(100, 'order_123');
        
        $this->assertDatabaseHas('payments', [
            'order_id' => 'order_123',
            'status' => 'completed'
        ]);
    }
}
```

### 3. Feature (Функциональные) тесты
* **Что тестируем:** Полный пользовательский сценарий
* **Зависимости:** Мокаем только ВНЕШНИЕ сервисы
* **БД:** Да (реальная, но тестовая)
* **Внешние API:** Мокаем
* **Цель:** Проверить, что фича работает от начала до конца

```php
class OrderCreationTest extends TestCase
{
    use RefreshDatabase; // Используем реальную БД в памяти

    public function test_user_can_create_order()
    {
        // 1. Создаем пользователя (реальный, в БД)
        $user = User::factory()->create();
        $this->actingAs($user);

        // 2. Мокаем внешний платежный шлюз
        Http::fake([
            'payment-gateway.com/*' => Http::response(['transaction_id' => '123'], 200)
        ]);

        // 3. Выполняем ПОЛНЫЙ HTTP-запрос
        $response = $this->postJson('/api/orders', [
            'product_id' => 1,
            'quantity' => 2
        ]);

        // 4. Проверяем ВЕСЬ ответ
        $response->assertStatus(201)
            ->assertJsonStructure(['id', 'total', 'status', 'transaction_id']);

        // 5. Проверяем побочные эффекты (реальная БД)
        $this->assertDatabaseCount('orders', 1);
        $this->assertDatabaseHas('orders', ['status' => 'paid']);
    }
}
```
### Моки внешних HTTP-запросов:
Для внешних запросов использовать **Mockery** или встроенные моки **PHPUnit** (Laravel Http Facade fake).

**В Feature тестах (рекомендуется):**
```php
// Или в Laravel для HTTP-тестов
Http::fake([
    'api.example.com/*' => Http::response(['success' => true], 200)
]);

// Тестируем контроллер, который делает запрос к api.example.com
$response = $this->get('/api/some-endpoint');
```
**В Integration/Unit тестах (для сервисов):**
```php
// Создаем мок HTTP-клиента
$httpMock = Mockery::mock(ClientInterface::class);
$httpMock->shouldReceive('post')
    ->once()
    ->andReturn(new Response(200, [], 'OK'));

$service = new ExternalApiService($httpMock);
$result = $service->callApi();
```

### Практика в Laravel:

**Для Unit тестов:**
- Наследуем от `Tests\TestCase`
- Используем моки для ВСЕХ зависимостей
- НЕ используем фасады БД

**Для Integration тестов:**
- Наследуем от `Tests\TestCase`
- Используем реальную БД (`RefreshDatabase` трейт)
- Мокаем только внешние сервисы

**Для Feature тестов:**
- Наследуем от `Tests\TestCase`
- Используем `$this->get()`, `$this->postJson()` и т.д.
- Тестируем полные HTTP-запросы

**Про инструменты для тестирования API:**
В Laravel использовать встроенные методы для тестирования API:
```php
// Тестирование REST API эндпоинта
$response = $this->postJson('/api/v1/orders', [
    'product_id' => 1,
    'quantity' => 2
]);

$response->assertStatus(201)
    ->assertJsonStructure([
        'id', 'total', 'status'
    ])
    ->assertJsonPath('status', 'pending');
```

### Ключевое правило для запоминания:
- **Unit** → тестируем один компонент → все зависимости мокаем
- **Integration** → тестируем взаимодействие нескольких компонентов → реальная БД, но внешние API мокаем
- **Feature** → тестируем пользовательский сценарий → реальная БД, мокаем внешнее, используем HTTP-запросы

## Active Record / Data Mapper

### Active Record (Laravel / Eloquent ORM)
**Суть паттерна Active Record такая:**
* модель одновременно представляет строку таблицы и умеет сама себя сохранять/обновлять/удалять;
* то есть модель содержит данные и логику работы с БД. 
* Также модель сама может **искать/читать** данные, Репозитории являются опциональными для сложных проектов

**Пример в Laravel:**
```php
$user = User::find(1);
$user->name = 'John';
$user->save();
```
**Модель:**
* хранит поля id, name
* сама знает, как себя сохранить (save())

**Плюсы:**
* простота и скорость разработки
* естественный и красивый синтаксис
* идеально для CRUD-логики

**Минусы:**
* «магия» и плотная связь модели и БД
* сложнее писать сложные доменные модели
* не всегда удобно тестировать

### Data Mapper (Symfony / Doctrine ORM)
**Суть паттерна Data Mapper:**
* Entity (Сущность) — это просто «адаптированный объект», чистый PHP-класс без связи с БД;
* Entity Manager — отвечает за **сохранение/изменение** (`persist`, `flush`).
* Repository (Репозиторий) — отвечает только за **поиск/чтение** данных (`find`, `findOneBy`).

**Пример в Symfony:**
```php
$user = new User();
$user->setName('John');

$em->persist($user);
$em->flush();
```

**Здесь:**
* у сущности нет методов save() или delete()
* работа с БД через EntityManager

**Плюсы:**
* чище архитектура
* легче следовать DDD (Domain Driven Design)
* меньше скрытой магии

**Минусы:**
* кривее порог входа, больше конфигурации
* код менее «приятен» для простых CRUD-задач