# Шпаргалка по теории, уровень Junior PHP/Laravel
<!-- TOC -->
* [Шпаргалка по теории, уровень Junior PHP/Laravel](#шпаргалка-по-теории-уровень-junior-phplaravel)
  * [1) Какие типы данных существуют в PHP?](#1-какие-типы-данных-существуют-в-php)
  * [2) Расскажи мне про callable подробнее:](#2-расскажи-мне-про-callable-подробнее)
  * [3) Enum это тип данных?](#3-enum-это-тип-данных)
  * [4) Что такое замыкание в PHP?](#4-что-такое-замыкание-в-php)
  * [5) Чем отличается замыкание от обычной функции?](#5-чем-отличается-замыкание-от-обычной-функции)
  * [6) Какая область видимости переменных у функции замыкания?](#6-какая-область-видимости-переменных-у-функции-замыкания)
  * [7) Чем отличается статическое замыкание от обычного замыкания?](#7-чем-отличается-статическое-замыкание-от-обычного-замыкания)
  * [8) Почему статическое быстрее, а обычное помедленнее?](#8-почему-статическое-быстрее-а-обычное-помедленнее)
  * [9) Что такое сборщик мусора?](#9-что-такое-сборщик-мусора)
  * [10) Какие виды ссылок есть в PHP?](#10-какие-виды-ссылок-есть-в-php)
  * [11) Что такое stdClass() ?](#11-что-такое-stdclass-)
  * [12) Что такое переменная переменной? Для чего и где это используется?](#12-что-такое-переменная-переменной-для-чего-и-где-это-используется)
  * [13) Что такое рекурсия?](#13-что-такое-рекурсия)
  * [14) Что происходит при бесконечной рекурсии?](#14-что-происходит-при-бесконечной-рекурсии)
  * [15) Основные отличия интерфейса от абстрактного класса?](#15-основные-отличия-интерфейса-от-абстрактного-класса)
  * [16) Для чего нужны сессии и где они хранятся?](#16-для-чего-нужны-сессии-и-где-они-хранятся)
  * [17) Транзакции, для чего нужны и как использовать?](#17-транзакции-для-чего-нужны-и-как-использовать)
  * [18) Что такое обфускатор и как его реализовать?](#18-что-такое-обфускатор-и-как-его-реализовать)
  * [19) Что такое идемпотентность?](#19-что-такое-идемпотентность)
  * [20) Какие бывают области видимости у переменных?](#20-какие-бывают-области-видимости-у-переменных)
  * [21) Какие коды HTTP ответов бывают, и на какие группы они разделяются?](#21-какие-коды-http-ответов-бывают-и-на-какие-группы-они-разделяются)
  * [22) Какие методы HTTP запросов бывают?](#22-какие-методы-http-запросов-бывают)
  * [23) Какие виды JOIN бывают в SQL?](#23-какие-виды-join-бывают-в-sql)
  * [24) Чем отличается LEFT от RIGHT JOIN?](#24-чем-отличается-left-от-right-join)
  * [25) Какие агрегатные функции есть в SQL?](#25-какие-агрегатные-функции-есть-в-sql)
  * [26) Чем отличается HAVING от WHERE?](#26-чем-отличается-having-от-where)
  * [27) Что такое индексы в БД и для чего они нужны, какие виды индексов существуют?](#27-что-такое-индексы-в-бд-и-для-чего-они-нужны-какие-виды-индексов-существуют)
  * [28) В каких ситуациях индекс хорош, а когда плох?](#28-в-каких-ситуациях-индекс-хорош-а-когда-плох)
  * [29) ACID, что это такое?](#29-acid-что-это-такое)
  * [30) Какие бывают базы данных, и чем они различаются между собой?](#30-какие-бывают-базы-данных-и-чем-они-различаются-между-собой)
  * [31) Clickhouse, какая БД? Реляционная или нет?](#31-clickhouse-какая-бд-реляционная-или-нет)
  * [32) В каком виде хранятся данные в PostgreSQL?](#32-в-каком-виде-хранятся-данные-в-postgresql)
  * [33) Что такое Redis, где используется?](#33-что-такое-redis-где-используется)
  * [34) Какие подтипы нереляционных БД существуют?](#34-какие-подтипы-нереляционных-бд-существуют)
  * [35) Что такое Explain, в контексте БД?](#35-что-такое-explain-в-контексте-бд)
  * [36) Как используется принцип SRP (SOLID) в Laravel?](#36-как-используется-принцип-srp-solid-в-laravel)
  * [37) В какой класс лучше вывести проверку данных (валидацию) с контроллера в Laravel?](#37-в-какой-класс-лучше-вывести-проверку-данных-валидацию-с-контроллера-в-laravel)
  * [38) Какой принцип SOLID будет использован при разделении данного контроллера?](#38-какой-принцип-solid-будет-использован-при-разделении-данного-контроллера)
  * [39) Расскажи про жизненный цикл запроса в Laravel?](#39-расскажи-про-жизненный-цикл-запроса-в-laravel)
  * [40) В 10 версии Laravel существовал therm файл за что он отвечал?](#40-в-10-версии-laravel-существовал-therm-файл-за-что-он-отвечал)
  * [41) Что такое middleware в Laravel, и какой функционал он выполняет?](#41-что-такое-middleware-в-laravel-и-какой-функционал-он-выполняет)
  * [42) Что такое события в Laravel, как и где используются?](#42-что-такое-события-в-laravel-как-и-где-используются)
  * [43) Что такое обсерверы?](#43-что-такое-обсерверы)
  * [44) Как в Laravel можно ограничить количество подключений одного пользователя к ip адресу приложения?](#44-как-в-laravel-можно-ограничить-количество-подключений-одного-пользователя-к-ip-адресу-приложения)
  * [45) Как в Laravel реализовываются запросы на сторонние приложения, что для этого применяются?](#45-как-в-laravel-реализовываются-запросы-на-сторонние-приложения-что-для-этого-применяются)
  * [46) Что такое Guzzle в чем его удобство, и какую функцию он реализует в PHP?](#46-что-такое-guzzle-в-чем-его-удобство-и-какую-функцию-он-реализует-в-php)
  * [47) Можно ли по нему авторизовываться?](#47-можно-ли-по-нему-авторизовываться)
  * [48) Какая структура HTTP запроса?](#48-какая-структура-http-запроса)
  * [49) В каком элементе запроса хранятся данные по авторизации?](#49-в-каком-элементе-запроса-хранятся-данные-по-авторизации)
  * [50) Что такое Bearer?](#50-что-такое-bearer)
  * [51) Что такое Eloquent ORM, для чего используется, какие типы связи есть?](#51-что-такое-eloquent-orm-для-чего-используется-какие-типы-связи-есть)
  * [52) Что такое SQL инъекции?](#52-что-такое-sql-инъекции)
  * [53) ORM защищает от SQL инъекций? Или все равно можно получить несанкционированый доступ?](#53-orm-защищает-от-sql-инъекций-или-все-равно-можно-получить-несанкционированый-доступ)
  * [54) Что такое Job в Laravel, для чего они нужны, как они работают, кто их запускает?](#54-что-такое-job-в-laravel-для-чего-они-нужны-как-они-работают-кто-их-запускает)
  * [55) Какой инструмент в Laravel управляет этими очередями?](#55-какой-инструмент-в-laravel-управляет-этими-очередями)
  * [56) Что такое Supervisor?](#56-что-такое-supervisor)
  * [57) Сколько Worker можно запустить на 1 задачу? Для чего это делается?](#57-сколько-worker-можно-запустить-на-1-задачу-для-чего-это-делается)
  * [58) Где хранятся настройки Laravel?](#58-где-хранятся-настройки-laravel)
  * [59) Какие минусы могут возникнуть при использовании обсервера в контроллере? Например в Post при привязке тегов?](#59-какие-минусы-могут-возникнуть-при-использовании-обсервера-в-контроллере-например-в-post-при-привязке-тегов)
  * [60) Если после изменения роутинга, перестал работать проект, какие команды рекомендуется использовать в Laravel?](#60-если-после-изменения-роутинга-перестал-работать-проект-какие-команды-рекомендуется-использовать-в-laravel)
  * [61) Вопрос по гиту, предположим начинаем свою ветку переносить в мастер, и появился конфликт, какие наши первые действия?](#61-вопрос-по-гиту-предположим-начинаем-свою-ветку-переносить-в-мастер-и-появился-конфликт-какие-наши-первые-действия)
  * [62) Что такое чери пик?](#62-что-такое-чери-пик)
  * [63) Чем отличается git merge от git rebase?](#63-чем-отличается-git-merge-от-git-rebase)
  * [64) Как работает команда git reset?](#64-как-работает-команда-git-reset)
<!-- TOC -->

## 1) Какие типы данных существуют в PHP?
- **Скалярные**: bool, int, float, string

- **Составные**: array, object, callable, iterable

- **Специальные**: resource, null, Enum

- **Псевдотипы**: mixed, void, never

## 2) Расскажи мне про callable подробнее:
```php
// Функция
$func = 'strlen';

// Метод объекта
$callable = [$object, 'methodName'];

// Статический метод
$staticCallable = ['ClassName', 'staticMethod'];
```

## 3) Enum это тип данных?
**Enum (перечисление)** — это специальный тип данных, который представляет собой ограниченный набор именованных значений. В PHP, начиная с версии 8.1, Enums реализованы как особый вид классов.

## 4) Что такое замыкание в PHP?
**Замыкание (Closure)** в PHP — это особый вид анонимной функции (функции без имени), которая обладает "памятью": она способна захватывать и получать доступ к переменным из той области видимости, в которой была создана, даже после того, как эта родительская область видимости перестала существовать.

## 5) Чем отличается замыкание от обычной функции?
Главное отличие замыкания от обычной функции в PHP заключается в области видимости переменных (scope) и способности захватывать эти переменные. А также именование и объявление.

## 6) Какая область видимости переменных у функции замыкания?
Область видимости переменных у функции замыкания — это двойная (или комбинированная) область видимости.

## 7) Чем отличается статическое замыкание от обычного замыкания?
Статическое замыкание не имеет доступа к `$this`, не привязано к объекту-контексту, нельзя перепривязать. НЕ держит ссылку на объект, поэтому легковесное, и может быть удален сборщиком мусора (Предотвращает утечки памяти). Лучше для утилитарных функций.

## 8) Почему статическое быстрее, а обычное помедленнее?
Потому что оно не выполняет логику связывания с объектом и, следовательно, требует меньше шагов для выполнения

## 9) Что такое сборщик мусора?
**Сборщик мусора (Garbage Collector, GC)** — это механизм в языках программирования с автоматическим управлением памятью (таких как PHP, Java, Python), который автоматически находит и удаляет объекты или данные, которые больше не используются приложением.

**Его основная задача** — освобождать оперативную память, чтобы предотвратить её переполнение (утечки памяти) и сделать процесс разработки более простым.

## 10) Какие виды ссылок есть в PHP?
- **Жесткие ссылки (&)** - прямое связывание переменных
- **Ссылки на объекты** - объекты всегда передаются по ссылке
- **Символические ссылки ($$var)** - динамические имена переменных
- **Ссылки в функциях** - изменение переданных параметров
- **Ссылки в массивах** - изменение элементов при переборе
- **Callable ссылки** - ссылки на функции и методы
- **Ссылки в замыканиях** - захват переменных по ссылке

## 11) Что такое stdClass() ?
**stdClass** — это специальный, встроенный класс в PHP, который служит базовым, анонимным (или пустым) контейнером для данных. Он не имеет никаких методов, определённых пользователем, и по сути является эквивалентом универсального, безымянного объекта.

## 12) Что такое переменная переменной? Для чего и где это используется?
**Переменная переменной** — это переменная, имя которой динамически определяется значением другой переменной. `($$)`.

## 13) Что такое рекурсия?
**Рекурсия (Recursion)** — это метод в программировании, при котором функция вызывает саму себя непосредственно или опосредованно (через другую функцию) для решения задачи.

## 14) Что происходит при бесконечной рекурсии?
При бесконечной рекурсии происходит переполнение стека **(Stack Overflow)**, что в итоге приводит к аварийному завершению (остановке) выполнения скрипта PHP.

## 15) Основные отличия интерфейса от абстрактного класса?
**Интерфейс** 
 - Только контракт (методы без тела)
 - Методы только `public`
 - Не может иметь свойств (только константы)
 - Класс может реализовать много интерфейсов
 - Используется для описания что класс должен уметь делать

**Абстрактный класс** 
 - Может содержать и контракт, и готовую реализацию
 - Методы могут быть `public/protected/private`
 - Может иметь любые свойства
 - Класс может наследовать только один абстрактный класс
 - Используется для описания общего поведения и структуры

## 16) Для чего нужны сессии и где они хранятся?
**Сессии** — это механизм для сохранения данных между разными запросами от одного пользователя. Они позволяют **"помнить"** состояние пользователя при переходе между страницами.

**Сессии нужны для:** 
 - Сохранения состояния между запросами
 - Аутентификации и авторизации
 - Корзин покупок
 - Многошаговых форм
 - Пользовательских настроек

**Где хранятся:** На сервере хранятся файлы 
 - **Файлы** - по умолчанию
 - **База данных** - для кластеров и больших проектов
 - **Redis/Memcached** - для высокой производительности)
 - У клиента хранится `cookie` с `PHPSESSID`, которая автоматически передается на сервер

## 17) Транзакции, для чего нужны и как использовать?
**Транзакции** — это механизм, который позволяет выполнять несколько SQL-запросов как единую атомарную операцию. Либо выполняются все запросы, либо ни один из них.

**ACID** свойства транзакций
- **Atomicity (Атомарность)** - Все или ничего
- **Consistency (Согласованность)** - Данные всегда в валидном состоянии
- **Isolation (Изолированность)** - Транзакции не мешают друг другу
- **Durability (Долговечность)** - Результаты сохраняются после завершения.

**Использование**: 
 - **SQL** 

```sql
START TRANSACTION/BEGIN;
COMMIT;
ROLLBACK;
```
 
 - **PDO** 

```php
try {
    $pdo->beginTransaction(); // начинаем транзакцию

    $pdo->exec("UPDATE accounts SET balance = balance - 100 WHERE id = 1");
    $pdo->exec("UPDATE accounts SET balance = balance + 100 WHERE id = 2");

    $pdo->commit(); // фиксируем изменения
} catch (Exception $e) {
    $pdo->rollBack(); // откатываем при ошибке
    echo "Ошибка: " . $e->getMessage();
}
```

 - **LARAVEL**

```php
// Автоматическая обработка транзакций
DB::transaction(function () use ($userId, $orderData) {
    // Создаем заказ
    $order = Order::create([
        'user_id' => $userId,
        'total' => $orderData['total']
    ]);
    
    // Добавляем товары
    foreach ($orderData['items'] as $item) {
        $order->items()->create([
            'product_id' => $item['product_id'],
            'quantity' => $item['quantity'],
            'price' => $item['price']
        ]);
        
        // Обновляем склад
        $product = Product::find($item['product_id']);
        $product->decrement('stock', $item['quantity']);
    }
    
    // Если произойдет любая ошибка - автоматический rollback
});

// Ручное управление
DB::beginTransaction();
try {
    // Логика...
    DB::commit();
} catch (Exception $e) {
    DB::rollBack();
    throw $e;
}
```


## 18) Что такое обфускатор и как его реализовать?
**Обфускация** — это процесс «запутывания» исходного кода, чтобы его было сложно читать и анализировать.

Код работает так же, как и до обфускации, но для человека становится непонятным.

**Используется**:
- для защиты коммерческих приложений (чтобы сложнее было украсть логику);
- для защиты от реверс-инжиниринга;
- иногда — чтобы спрятать лицензионные проверки, ключи и т. д.

**Основные техники**:
- Переименование переменных, функций, классов `preg_replace()`
- Удаление комментариев и форматирования `preg_replace()`, `trim()`
- Шифрование строковых литералов `base64_encode/base64_decode`
- Добавление ложного кода (fake)
- Динамическое выполнение `eval`, `call_user_func`

## 19) Что такое идемпотентность?
**Идемпотентность** — это свойство операции или метода, которое означает, что многократное выполнение этой операции с одинаковыми входными данными приводит к тому же самому результату (или состоянию системы), как если бы операция была выполнена только один раз.

- Идемпотентность = повторение операции не меняет результат.
- В коде: присвоение значения переменной.
- В API: GET, PUT, DELETE → идемпотентные, POST, PATCH → нет.

**Идемпотентность** — это критически важное свойство для:
- Надежных API - защита от дублирующих запросов
- Распределенных систем - безопасные retry механизмы
- Очередей сообщений - обработка дубликатов сообщений
- Финансовых операций - предотвращение двойных списаний

## 20) Какие бывают области видимости у переменных?
- **Локальная** - внутри функций, уничтожается после выполнения
- **Глобальная** - доступна везде в скрипте `global`, `$GLOBALS`
- **Статическая** - сохраняет значение между вызовами функции `static`
- **Public** - доступна отовсюду (классы)
- **Protected** - доступна в классе и наследниках
- **Private** - доступна только в объявляющем классе
- **Замыкания** - захватывают переменные из внешней области `use`

## 21) Какие коды HTTP ответов бывают, и на какие группы они разделяются?
**1xx: Информационные (Informational)**
- 100 Continue — сервер принял заголовки, можно отправлять тело запроса.
- 101 Switching Protocols — переключение протоколов (например, на WebSocket).

**2xx: Успех (Success)**
- 200 OK — всё хорошо, стандартный успешный ответ.
- 201 Created — ресурс успешно создан (часто при POST).
- 204 No Content — успешно, но без тела ответа (например, при DELETE).

**3xx: Перенаправление (Redirection)**
- 301 Moved Permanently — постоянный редирект.
- 302 Found — временный редирект.
- 304 Not Modified — ресурс не изменился (используется при кешировании).

**4xx: Ошибка клиента (Client Error)**
- 400 Bad Request — некорректный запрос.
- 401 Unauthorized — нужна авторизация.
- 403 Forbidden — доступ запрещён, даже если авторизован.
- 404 Not Found — ресурс не найден.
- 422 Unprocessable Entity — сервер понял запрос, но не может обработать (часто в API при валидации).

**5xx: Ошибка сервера (Server Error)**
- 500 Internal Server Error — общая ошибка.
- 502 Bad Gateway — неверный ответ от прокси/шлюза.
- 503 Service Unavailable — сервис временно недоступен (например, перегрузка).
- 504 Gateway Timeout — шлюз не дождался ответа.

## 22) Какие методы HTTP запросов бывают?
**GET**
- Назначение: получить ресурс(ы).
- Тело запроса обычно не используется.
- Safe (должен только читать), идемпотентен.

**POST**
- Назначение: создать ресурс или выполнить действие.
- Обычно содержит тело (form/json).
- Не идемпотентен (каждый вызов может создать новый ресурс).

**PUT**
- Назначение: замена ресурса целиком (или создание по указанному URI).
- Обычно идемпотентен: повторные вызовы дают тот же результат.

**PATCH**
- Назначение: частичное обновление ресурса (patch — "заплатка").
- Может быть идемпотентен, но не обязателен — зависит от реализации.

**DELETE**
- Назначение: удалить ресурс.
- Обычно идемпотентен: удалить уже удалённый ресурс — результат тот же (ошибка/пустой ответ).

**HEAD**
- То же, что GET, но без тела ответа — только заголовки (используется для проверки наличия ресурса, кеширования).
- Safe, идемпотентен.

**OPTIONS**
- Возвращает, какие методы поддерживаются на данном ресурсе (CORS/policy часто используют).
- Safe, идемпотентен.

**CONNECT** — устанавливает туннель (обычно для прокси/HTTPS).

**TRACE** — эхо-запрос (диагностика) — редко и обычно блокируется (опасно).

## 23) Какие виды JOIN бывают в SQL?
- INNER JOIN
- LEFT JOIN (LEFT OUTER JOIN)
- RIGHT JOIN (RIGHT OUTER JOIN)
- FULL OUTER JOIN
- CROSS JOIN

## 24) Чем отличается LEFT от RIGHT JOIN?
Какая таблица будет главная левая (FROM) или правая (JOIN))

## 25) Какие агрегатные функции есть в SQL?
```sql
COUNT();
SUM();
AVG();
MIN()/MAX();
STRING_AGG();
ARRAY_AGG();
```
## 26) Чем отличается HAVING от WHERE?
**WHERE** — фильтрует строки ДО группировки (фильтр на SELECT)

**HAVING** — фильтрует результаты ПОСЛЕ группировки (фильтр на GROUP BY)

## 27) Что такое индексы в БД и для чего они нужны, какие виды индексов существуют?
**Индекс** — это специальная структура данных, которая ускоряет операции поиска в таблице. Можно сравнить с оглавлением в книге или алфавитным указателем.

Для чего нужны индексы?   
- Ускорение поиска (WHERE, JOIN)
- Ускорение сортировки (ORDER BY)
- Обеспечение уникальности (UNIQUE constraints)
- Ускорение группировки (GROUP BY)

Основные виды индексов:
- Первичный индекс (Primary Key Index)
- Уникальный индекс (Unique Index)
- Составной индекс (Composite/Compound Index)
- Полнотекстовый индекс (Full-Text Index)
- SPATIAL (геоиндекс)

## 28) В каких ситуациях индекс хорош, а когда плох?
«Индексируй только то, что читаешь часто, и не индексируй то, что часто изменяешь»

Когда индекс ХОРОШ:
- Частые поиски по конкретному полю (WHERE)
- Внешние ключи и JOIN'ы
- Сортировка и группировка (ORDER BY, GROUP BY)
- Уникальные столбцы (UNIQUE или PRIMARY KEY)
- Столбцы с высокой кардинальностью
- Составные условия поиска

Когда индекс ПЛОХ (или бесполезен):
- Поля с низкой кардинальностью (например, status, gender или is_active)
- Часто обновляемые таблицы (Логи, INSERT, UPDATE или DELETE)
- Маленькие таблицы (Таблица на 100-500 строк)
- Поля, которые никогда не используются в WHERE (Очень большие текстовые поля)
- Слишком много индексов на одной таблице

## 29) ACID, что это такое?
**ACID** — это набор свойств, которые гарантируют надежность и предсказуемость транзакций в базах данных. Это фундаментальная концепция, особенно важная для финансовых приложений, где критически важна целостность данных.
- **Atomicity** (Атомарность) (Принцип: "Все или ничего" — транзакция выполняется либо полностью, либо не выполняется вовсе.)
- **Consistency** (Согласованность) (Принцип: Транзакция переводит базу данных из одного согласованного состояния в другое.)
- **Isolation** (Изолированность) (Принцип: Параллельные транзакции не должны мешать друг другу.)
- **Durability** (Долговечность) (Принцип: Если транзакция завершена (committed), ее результаты гарантированно сохраняются, даже при сбое системы.)

## 30) Какие бывают базы данных, и чем они различаются между собой?
**Реляционные базы данных (SQL)** (MySQL, PostgreSQL, MariaDB, SQLite, MS SQL Server, Oracle.)
- Модель данных - Таблицы, связи
- Масштабирование - Вертикальное
- Сильные стороны - Транзакции, целостность

**Документно-ориентированные (NoSQL)** (MongoDB, CouchDB, Firebase Firestore)
- Модель данных - JSON/BSON/XML-документы
- Масштабирование - Горизонтальное
- Сильные стороны - Гибкость, производительность

**Ключ–значение (Key-Value Stores)** (Redis, Memcached, DynamoDB.)
- Модель данных - Key-Value пары
- Масштабирование - Горизонтальное
- Сильные стороны - Скорость, кэширование

**Графовые базы данных** (Neo4j, OrientDB, ArangoDB.)
- Модель данных - Узлы и связи
- Масштабирование - Горизонтальное
- Сильные стороны - Поиск связей, рекомендации

**Колонночные базы данных** (ClickHouse, Cassandra, HBase.)
- Модель данных - Колонки
- Масштабирование - Горизонтальное
- Сильные стороны - Аналитика, агрегации, большие объемы данных (BigData)

**Поисковые движки** (Elasticsearch, OpenSearch)
- Модель данных - Документы + индекс
- Масштабирование - Горизонтальное
- Сильные стороны - Полнотекстовый поиск

**Временные (Time Series) базы данных** (InfluxDB, TimescaleDB, Prometheus.)

## 31) Clickhouse, какая БД? Реляционная или нет?
**ClickHouse** — не реляционная БД, а колоночная аналитическая система (OLAP-систем — Online Analytical Processing)
- SQL-совместимая (но с ограничениями)
- НЕ реляционная в классическом понимании
- НЕ для OLTP-нагрузок (Online Transaction Processing)
- Быстрые агрегатные функции по колонкам, БД работает на чтение > запись

## 32) В каком виде хранятся данные в PostgreSQL?
Данные в PostgreSQL хранятся в виде строк (Rows), организованных в таблицы (Tables), что соответствует реляционной модели. Однако на физическом уровне (на диске) данные хранятся в виде файлов, состоящих из страниц (Pages).

## 33) Что такое Redis, где используется?
**Redis** — это (in-memory) база данных типа "ключ-значение" с открытым исходным кодом. Название расшифровывается как REmote DIctionary Server.

**Хорошие сценарии**:
- Кэширование (сессии, HTML, данные)
- Очереди (отложенные задачи)
- Счетчики (просмотры, лайки)
- Временные данные (корзины, коды подтверждения)
- Реальное время (чаты, уведомления)

**Плохие сценарии**:
- Большие бинарные данные (файлы, изображения)
- Сложные запросы (нет JOIN, WHERE)
- Данные > доступной RAM (вытеснение старых данных)
- Критически важные данные (риск потери при перезагрузке)

## 34) Какие подтипы нереляционных БД существуют?
Документные БД (Document Stores) 
- Хранение документов в формате JSON/BSON/XML 
- MongoDB/Couchbase

Ключ-Значение (Key-Value Stores) 
- Простой словарь ключ → значение
- Redis/Memcached

Колоночные БД (Column-Family Stores) 
- Данные хранятся по колонкам, а не по строкам 
- ClickHouse/Cassandra

Графовые БД (Graph Databases) 
- Узлы (nodes-сущности) и ребра (edges-связи) 
- Neo4j

Поисковые движки (Search Engines)
- Специализированные БД для полнотекстового поиска
- Elasticsearch/OpenSearch

БД временных рядов (Time-Series Databases)
- Оптимизированы для данных с метками времени
- InfluxDB

## 35) Что такое Explain, в контексте БД?
**EXPLAIN** — это команда в SQL-базах данных, которая показывает план выполнения запроса.
- Оптимизация медленных запросов
- Понимание как работает БД (использует ли запрос индексы, и какие)
- Выявление узких мест
- Проверка использования индексов

## 36) Как используется принцип SRP (SOLID) в Laravel?
Laravel сам реализует SRP во многих местах:
- Form Requests — только валидация.
- Middleware — только фильтрация и проверка запросов.
- Jobs / Listeners — выполняют одну задачу (например, отправку письма).
- Mailables — отвечают только за формирование письма.
- Policies / Gates — отвечают за авторизацию.

## 37) В какой класс лучше вывести проверку данных (валидацию) с контроллера в Laravel?
Для большинства случаев — Form Request.

Альтернативы:
- Service Classes
- Custom Validator
- Traits
- Rules Objects

## 38) Какой принцип SOLID будет использован при разделении данного контроллера?
Основной принцип: SRP (Single Responsibility Principle).

Дополнительно применяются:
- DIP через dependency injection
- OCP через возможность расширения
- LSP через заменяемость сервисов
- ISP через разделенные интерфейсы

## 39) Расскажи про жизненный цикл запроса в Laravel?
**1. Вход в приложение (public/index.php):**
- Загружает автозагрузчик Composer'а
- Создаёт и запускает ядро приложения (App\Http\Kernel)

**2. Создание экземпляра приложения (app.php):**
- Файл bootstrap/app.php создаёт основу фреймворка — контейнер зависимостей (Service Container).

**3. Обработка через HTTP Kernel**

**4. Middleware Pipeline (Запрос проходит через стек middleware):**
  - Глобальные Middleware (Request → TrustProxies → CheckForMaintenanceMode → ValidatePostSize →)
  - Группы Middleware (например, 'web') (→ EncryptCookies → VerifyCsrfToken → ...)

**5. Маршрутизация: Router (Router находит подходящий маршрут)**

**6. Контроллер и обработка**
  - Получает данные от пользователя;
  - Может вызвать модель, сервис, валидацию (FormRequest);

**7. Модели и Eloquent ORM**

**8. Service Providers Загрузка**

**9. Возврат Response:**
  - return response()->json($data);
  - return view('template');
  - return redirect('/home');
  - Middleware обрабатывают response на обратном пути (← AddHeaders ← EncryptCookies ← ...)

**10. Завершение: Termination и HTTP Response клиенту**

## 40) В 10 версии Laravel существовал therm файл за что он отвечал?
- Временный маркер для отслеживания состояния приложения
- Инструмент для "hot reload" в режиме разработки
- Автоматически управляется фреймворком
- Не предназначен для ручного редактирования
- Не должен попадать в репозиторий

## 41) Что такое middleware в Laravel, и какой функционал он выполняет?
**Middleware** (Промежуточное ПО) в Laravel — это механизм, который действует как фильтр, обрабатывая HTTP-запросы, прежде чем они достигнут контроллера, и HTTP-ответы, прежде чем они будут отправлены клиенту.

**Схема** (HTTP Request → Global Middleware → Route Middleware → Controller → Route Middleware → Global Middleware → HTTP Response)

**Использование** (Аутентификация, Защита CSRF, Кэширование, Throttling, CORS, Обслуживание, Локализация, Логирование)

## 42) Что такое события в Laravel, как и где используются?
**События (Events)** в Laravel — это простой и мощный механизм паттерна **Наблюдатель (Observer Pattern)**. Они позволяют регистрировать определённые действия или происшествия в приложении и прикреплять к ним обработчики (Listeners).
- События (Events) — это способ сообщить системе, что что-то произошло.
- Слушатели (Listeners) — это куски кода, которые реагируют на это событие.

**Когда использовать события?**
- Отправка уведомлений
- Обновление связанных данных
- Логирование активности
- Кэширование и инвалидация
- Интеграция с внешними сервисами

## 43) Что такое обсерверы?
**Обсерверы (Observers)** в Laravel — это специальные классы, которые позволяют "наблюдать" за событиями модели Eloquent и реагировать на них. (creating, created, updating, updated, deleting, deleted, restoring, restored)

**Когда использовать обсерверы:**
- Генерация slug
- Удаление файлов при удалении модели
- Логирование изменений
- Отправка уведомлений при создании

## 44) Как в Laravel можно ограничить количество подключений одного пользователя к ip адресу приложения?
Throttle Middleware (Встроенная защита)

Rate Limiting с аутентификацией

Кастомный Rate Limiter

## 45) Как в Laravel реализовываются запросы на сторонние приложения, что для этого применяются?
Фасад HTTP Client Laravel (Guzzle под капотом)

## 46) Что такое Guzzle в чем его удобство, и какую функцию он реализует в PHP?
**Guzzle** — это PHP HTTP-клиент, который упрощает отправку HTTP-запросов и интеграцию с веб-сервисами. Это библиотека, на которой построен HTTP-клиент Laravel.
- Назначение	Выполнение HTTP-запросов
- Реализует	Клиент для REST, SOAP, JSON API и т.д.
- Под капотом	cURL
- Используется в	Laravel (Http), Symfony, WordPress, SDK от AWS и др.
- Уровень	Must-have для любого backend-разработчика

## 47) Можно ли по нему авторизовываться?
Guzzle отлично подходит для авторизации и поддерживает:
- Bearer Tokens (JWT, OAuth)
- OAuth 1.0/2.0 все flow
- Basic/Digest Auth
- API Keys (headers, query params)
- Cookie-based аутентификация
- Кастомные схемы аутентификации

## 48) Какая структура HTTP запроса?
**Start Line (Первая строка)** (GET /api/users HTTP/1.1):
- Метод - GET, POST, PUT, DELETE и т.д.
- URI - путь к ресурсу (/api/users)
- Версия HTTP - HTTP/1.1 или HTTP/2

**Headers (Заголовки)**
- Общие заголовки (Connection, Cache-Control)
- Заголовки запроса (Host, User-Agent, Accept, Accept-Language, Accept-Encoding, Authorization)
- Заголовки содержимого (Content-Type, Content-Length, Content-Encoding)

**Empty Line (Пустая строка)** (разделитель между заголовками и телом)

**Body (Тело запроса)** - опционально

**ПРИМЕР POST запрос с JSON телом:**
```json
POST /api/users HTTP/1.1
Host: api.example.com
Content-Type: application/json
Content-Length: 87
Authorization: Bearer token123
User-Agent: MyApp/1.0

{
"name": "Alice Smith",
"email": "alice@example.com",
"password": "securepassword123"
}
```
## 49) В каком элементе запроса хранятся данные по авторизации?
**Authorization Header** (Самый распространенный):
- Bearer Token (JWT, OAuth) (Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...)
- Basic Auth (Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=) - login:password в base64
- Digest Auth (Authorization: Digest username="user", realm="example", nonce="abc123")
- API Key (иногда) (Authorization: APIKey your-api-key-here)

**Custom Headers** (Кастомные заголовки) (X-API-Key, X-API-Token, X-Auth-Token, API-Key)

**Cookies (Для сессий**) (Cookie: session_id=abc123def456; auth_token=xyz789;)

**Query Parameters (В URL)** (GET /api/data?api_key=your_key_123&token=abc123)

**Body Data** (Form-based аутентификация)

## 50) Что такое Bearer?
**Bearer (от англ. "носитель")** — это тип аутентификации, где наличие токена дает право доступа к защищенным ресурсам. Тот, кто "несет" (has bearer) токен, получает доступ.

**Authorization: Bearer <token>**
- Схема аутентификации для передачи токенов
- Простой стандарт - Authorization: Bearer <token>
- Универсальный - работает с JWT, OAuth, кастомными токенами
- Без состояния (stateless) - серверу не нужно хранить сессию
- Стандарт де-факто для REST API и мобильных приложений

## 51) Что такое Eloquent ORM, для чего используется, какие типы связи есть?
**Eloquent ORM (Object-Relational Mapping)** — это реализация паттерна Active Record в Laravel, который позволяет работать с базой данных используя объектно-ориентированный синтаксис вместо SQL запросов.

**Для чего используется Eloquent?**
- Упрощение работы с БД
- Объектно-ориентированный подход
- Безопасность от SQL-инъекций

**Типы связей в Eloquent:**
- One To One (Один к одному) (User hasOne Profile, Profile belongsTo User)
- One To Many (Один ко многим) (User hasMany Post, Post belongsTo User)
- Many To Many (Многие ко многим) (Post belongsToMany Tag, Tag belongsToMany Post) PIVOT table post_tag
- Has Many Through (Имеет много через) (Country hasManyThrough Post, User)
- Polymorphic Relations (Полиморфные связи) (Comment morphTo, Post morphMany Comment, Video morphMany Comment)
- Many To Many Polymorphic (Полиморфные многие ко многим) (Tag morphedByMany Post, Tag morphedByMany Video, Post morphToMany Tag, Video  morphToMany Tag)

## 52) Что такое SQL инъекции?
**SQL инъекция** — это атака, при которой злоумышленник внедряет вредоносный SQL-код в запросы к базе данных, чтобы получить несанкционированный доступ к данным или выполнить несанкционированные операции.

`(' OR '1'='1' --)`

**Защита от SQL инъекций:**
- Подготовленные выражения (Prepared Statements)
- Экранирование данных

## 53) ORM защищает от SQL инъекций? Или все равно можно получить несанкционированый доступ?
**ЗАЩИЩЕНО автоматически:**
- Все методы Eloquent (where(), find(), create() etc.)
- Query Builder с биндингом параметров
- PDO prepared statements

**ТРЕБУЕТ осторожности:**
- DB::raw(), whereRaw(), selectRaw()
- DB::statement()
- Динамические имена таблиц/колонок (Нужно делать белые списки для ORDER BY)

**НЕ ЗАЩИЩАЕТ от:**
- Logic flaws (логические ошибки приложения)
- Mass assignment (если не настроены $fillable/$guarded)
- NoSQL injection (для нереляционных БД)
- XSS, CSRF, etc. (другие типы атак)

## 54) Что такое Job в Laravel, для чего они нужны, как они работают, кто их запускает?
**Job** — это класс, который представляет собой задачу, которая может быть выполнена в фоновом режиме, отдельно от основного HTTP-запроса.

**Для чего нужны Jobs?**
- Долгие операции (обработка видео)
- Отправка email
- Обработка данных (Генерация отчетов, Синхронизация с внешними API, Обработка изображений)

**Как работают Jobs?**
- Диспатч: ProcessPayment::dispatch($user, 100)
- Сериализация: Job преобразуется в JSON и сохраняется в очередь
- Хранение: Данные хранятся в Redis/Database/SQS
- Обработка: Worker забирает задачу из очереди
- Выполнение: Вызывается метод handle()
- Завершение: Job удаляется из очереди

**Кто запускает Jobs?**

Jobs не запускаются самим PHP-скриптом, который обрабатывает HTTP-запрос. Их запускают Worker-процессы (рабочие процессы).
- Worker (Рабочий процесс): Это процесс, запущенный в фоновом режиме на сервере, который постоянно слушает очередь.
- Команда Artisan: Worker запускается с помощью команды Artisan Queue Worker (php artisan queue:work)
- Менеджеры процессов: На продакшене queue:work запускается и управляется специальными менеджерами процессов (например, Supervisor), которые гарантируют, что Worker всегда активен, перезапускается при сбоях и запускается при старте сервера.

## 55) Какой инструмент в Laravel управляет этими очередями?
**Разработка**: queue:listen или queue:work

**Продакшен**: Horizon (Redis) + Supervisor (Unix)

**Администрирование**: Artisan commands (queue:failed, queue:retry)

## 56) Что такое Supervisor?
**Supervisor** — это системный демон для Unix-систем, который управляет процессами и гарантирует их постоянную работу.
- Запускает процессы и следит за их работой
- Автоматически перезапускает упавшие процессы
- Управляет несколькими процессами одновременно
- Предоставляет веб-интерфейс для мониторинга

## 57) Сколько Worker можно запустить на 1 задачу? Для чего это делается?
На одну задачу (Job) → 1 Worker

Но на тип задач можно запустить много Workers для:
- Параллелизм - 8 workers вместо 1 (В 8 раз быстрее обработка)
- Пиковые нагрузки - 50 workers на Black Friday (Без задержек для пользователей)
- Приоритизация - 10 workers для платежей, 2 для email (Важные задачи обрабатываются первыми)
- Балансировка - Разные workers для CPU/I/O задач (Оптимальное использование ресурсов)

## 58) Где хранятся настройки Laravel?
Файлы конфигурации (config/)

Файлы переменных окружения (.env)

Файлы окружения по environment (опционально) (.env.local, .env.staging, .env.production)

## 59) Какие минусы могут возникнуть при использовании обсервера в контроллере? Например в Post при привязке тегов?
- Нарушение Single Responsibility Principle (SRP)
- Сложность тестирования
- Неявные побочные эффекты
- Проблемы с транзакциями
- Сложность отладки

Правильная альтернатива: Service (Action) Class

## 60) Если после изменения роутинга, перестал работать проект, какие команды рекомендуется использовать в Laravel?
Приоритетная последовательность:
1. `php artisan route:clear`          - Самое важное!
2. `php artisan route:list`           - Проверить роуты
3. `composer dump-autoload`          - Перезагрузить классы
4. `php artisan cache:clear`         - Очистить кэш данных
5. `php artisan config:clear`        - Очистить кэш конфигов
   
Если не помогло:
6. `php artisan optimize:clear`      - Полная очистка
7. `php artisan package:discover`    - Пере discover пакетов
8. `php artisan route:cache`         - Кэшировать заново

## 61) Вопрос по гиту, предположим начинаем свою ветку переносить в мастер, и появился конфликт, какие наши первые действия?
- `git status` — посмотреть что случилось
- `git diff` — проанализировать конфликты
- Редактировать файлы — убрать `<<<<<<<, =======, >>>>>>>`
- `git add .` — добавить исправленные файлы
- `git commit` — завершить слияние
- `git push` — отправить изменения

## 62) Что такое чери пик?
**Cherry-pick** — это операция "выборочного копирования" конкретных коммитов между ветками.

**Когда использовать cherry-pick:**
- Срочные фиксы из development в production
- Backport исправлений между версиями
- Восстановление потерянных коммитов
- Частичный перенос фич

**Когда НЕ использовать cherry-pick:**
- Для регулярного кода между ветками
- Когда можно использовать merge/rebase
- Для больших feature-веток

## 63) Чем отличается git merge от git rebase?
`git merge` объединяет ветки, создавая новый merge-коммит и сохраняя историю ветвления.

`git rebase` переписывает историю, «перенося» коммиты одной ветки поверх другой,
делая историю линейной.

В рабочих ветках часто используют `rebase` для чистой истории,
а в общих ветках — `merge`, чтобы избежать конфликтов истории.

## 64) Как работает команда git reset?
`git reset` перемещает указатель ветки (HEAD) на другой коммит и опционально обновляет рабочую директорию и индекс.
1. `--soft` — Только перемещает HEAD
2. `--mixed` (по умолчанию) — + Обновляет индекс
3. `--hard` — + Обновляет рабочую директорию