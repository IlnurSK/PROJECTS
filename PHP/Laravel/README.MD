# Шпаргалка по теории, уровень Junior+/PreMiddle PHP/Laravel
<!-- TOC -->
* [Шпаргалка по теории, уровень Junior+/PreMiddle PHP/Laravel](#шпаргалка-по-теории-уровень-juniorpremiddle-phplaravel)
  * [1) Какие типы данных существуют в PHP?](#1-какие-типы-данных-существуют-в-php)
  * [2) Расскажи мне про callable подробнее:](#2-расскажи-мне-про-callable-подробнее)
  * [3) Enum это тип данных?](#3-enum-это-тип-данных)
  * [4) Что такое замыкание в PHP?](#4-что-такое-замыкание-в-php)
  * [5) Чем отличается замыкание от обычной функции?](#5-чем-отличается-замыкание-от-обычной-функции)
  * [6) Какая область видимости переменных у функции замыкания?](#6-какая-область-видимости-переменных-у-функции-замыкания)
  * [7) Чем отличается статическое замыкание от обычного замыкания?](#7-чем-отличается-статическое-замыкание-от-обычного-замыкания)
  * [8) Почему статическое быстрее, а обычное помедленнее?](#8-почему-статическое-быстрее-а-обычное-помедленнее)
  * [9) Что такое сборщик мусора?](#9-что-такое-сборщик-мусора)
  * [10) Какие виды ссылок есть в PHP?](#10-какие-виды-ссылок-есть-в-php)
  * [11) Что такое stdClass() ?](#11-что-такое-stdclass-)
  * [12) Что такое переменная переменной? Для чего и где это используется?](#12-что-такое-переменная-переменной-для-чего-и-где-это-используется)
  * [13) Что такое рекурсия?](#13-что-такое-рекурсия)
  * [14) Что происходит при бесконечной рекурсии?](#14-что-происходит-при-бесконечной-рекурсии)
  * [15) Основные отличия интерфейса от абстрактного класса?](#15-основные-отличия-интерфейса-от-абстрактного-класса)
  * [16) Для чего нужны сессии и где они хранятся?](#16-для-чего-нужны-сессии-и-где-они-хранятся)
  * [17) Транзакции в базах данных](#17-транзакции-в-базах-данных)
    * [Свойства ACID (основа транзакций)](#свойства-acid-основа-транзакций)
    * [Проблемы параллельных транзакций](#проблемы-параллельных-транзакций)
    * [Уровни изоляции (от слабого к строгому)](#уровни-изоляции-от-слабого-к-строгому)
    * [Управление транзакциями в MySQL](#управление-транзакциями-в-mysql)
    * [Транзакции в Laravel](#транзакции-в-laravel)
    * [Резюме](#резюме)
  * [18) Что такое обфускатор и как его реализовать?](#18-что-такое-обфускатор-и-как-его-реализовать)
  * [19) Что такое идемпотентность?](#19-что-такое-идемпотентность)
  * [20) Какие бывают области видимости у переменных?](#20-какие-бывают-области-видимости-у-переменных)
  * [21) Какие коды HTTP ответов бывают, и на какие группы они разделяются?](#21-какие-коды-http-ответов-бывают-и-на-какие-группы-они-разделяются)
  * [22) Какие методы HTTP запросов бывают?](#22-какие-методы-http-запросов-бывают)
  * [23) Какие виды JOIN бывают в SQL?](#23-какие-виды-join-бывают-в-sql)
  * [24) Чем отличается LEFT от RIGHT JOIN?](#24-чем-отличается-left-от-right-join)
  * [25) Какие агрегатные функции есть в SQL?](#25-какие-агрегатные-функции-есть-в-sql)
  * [26) SQL - Разница WHERE vs HAVING](#26-sql---разница-where-vs-having-)
    * [WHERE](#where)
    * [HAVING](#having)
    * [Ключевые различия](#ключевые-различия)
    * [Пример с обоими условиями](#пример-с-обоими-условиями)
    * [Частые ошибки](#частые-ошибки)
    * [Практическое правило](#практическое-правило)
    * [Что говорить на собеседовании](#что-говорить-на-собеседовании)
  * [27) Индексы в базах данных](#27-индексы-в-базах-данных)
    * [Зачем нужны индексы?](#зачем-нужны-индексы)
    * [Типы индексов по структуре хранения](#типы-индексов-по-структуре-хранения)
      * [B-Tree (B+Tree) — самый распространённый](#b-tree-btree--самый-распространённый)
      * [Hash индекс (Хэш-таблица)](#hash-индекс-хэш-таблица)
        * [Сравнительная таблица: B-tree vs Hash](#сравнительная-таблица-b-tree-vs-hash)
        * [Когда что использовать: практические сценарии](#когда-что-использовать-практические-сценарии)
        * [Пример из реальной жизни](#пример-из-реальной-жизни)
        * [Особенности в разных СУБД](#особенности-в-разных-субд)
        * [Резюме b-tree / hash](#резюме-b-tree--hash)
      * [Full-Text — полнотекстовый поиск](#full-text--полнотекстовый-поиск)
      * [Spatial (R-Tree) — геоданные](#spatial-r-tree--геоданные)
    * [Типы индексов по функциональности](#типы-индексов-по-функциональности)
      * [PRIMARY KEY (первичный ключ)](#primary-key-первичный-ключ)
      * [UNIQUE INDEX (уникальный индекс)](#unique-index-уникальный-индекс)
      * [INDEX (обычный, не уникальный)](#index-обычный-не-уникальный)
      * [COMPOSITE INDEX (составной, композитный)](#composite-index-составной-композитный)
    * [Кластеризованные vs Некластеризованные](#кластеризованные-vs-некластеризованные)
    * [Как MySQL выбирает индекс?](#как-mysql-выбирает-индекс)
    * [Проблемы с индексами](#проблемы-с-индексами)
    * [В каких ситуациях индекс хорош, а когда плох?](#в-каких-ситуациях-индекс-хорош-а-когда-плох)
    * [Резюме](#резюме-1)
  * [29) ACID, что это такое?](#29-acid-что-это-такое)
  * [30) Какие бывают базы данных, и чем они различаются между собой?](#30-какие-бывают-базы-данных-и-чем-они-различаются-между-собой)
  * [31) Clickhouse, какая БД? Реляционная или нет?](#31-clickhouse-какая-бд-реляционная-или-нет)
  * [32) В каком виде хранятся данные в PostgreSQL?](#32-в-каком-виде-хранятся-данные-в-postgresql)
  * [33) Что такое Redis, где используется?](#33-что-такое-redis-где-используется)
  * [34) Какие подтипы нереляционных БД существуют?](#34-какие-подтипы-нереляционных-бд-существуют)
  * [35) Что такое Explain, в контексте БД?](#35-что-такое-explain-в-контексте-бд)
  * [36) Как используется принцип SRP (SOLID) в Laravel?](#36-как-используется-принцип-srp-solid-в-laravel)
  * [37) В какой класс лучше вывести проверку данных (валидацию) с контроллера в Laravel?](#37-в-какой-класс-лучше-вывести-проверку-данных-валидацию-с-контроллера-в-laravel)
  * [38) Какой принцип SOLID будет использован при разделении данного контроллера?](#38-какой-принцип-solid-будет-использован-при-разделении-данного-контроллера)
  * [39) Расскажи про жизненный цикл запроса в Laravel?](#39-расскажи-про-жизненный-цикл-запроса-в-laravel)
  * [40) В 10 версии Laravel существовал therm файл за что он отвечал?](#40-в-10-версии-laravel-существовал-therm-файл-за-что-он-отвечал)
  * [41) Что такое middleware в Laravel, и какой функционал он выполняет?](#41-что-такое-middleware-в-laravel-и-какой-функционал-он-выполняет)
  * [42) Что такое события в Laravel, как и где используются?](#42-что-такое-события-в-laravel-как-и-где-используются)
  * [43) Что такое обсерверы?](#43-что-такое-обсерверы)
  * [44) Как в Laravel можно ограничить количество подключений одного пользователя к ip адресу приложения?](#44-как-в-laravel-можно-ограничить-количество-подключений-одного-пользователя-к-ip-адресу-приложения)
  * [45) Как в Laravel реализовываются запросы на сторонние приложения, что для этого применяются?](#45-как-в-laravel-реализовываются-запросы-на-сторонние-приложения-что-для-этого-применяются)
  * [46) Что такое Guzzle в чем его удобство, и какую функцию он реализует в PHP?](#46-что-такое-guzzle-в-чем-его-удобство-и-какую-функцию-он-реализует-в-php)
  * [47) Можно ли по нему авторизовываться?](#47-можно-ли-по-нему-авторизовываться)
  * [48) Какая структура HTTP запроса?](#48-какая-структура-http-запроса)
  * [49) В каком элементе запроса хранятся данные по авторизации?](#49-в-каком-элементе-запроса-хранятся-данные-по-авторизации)
  * [50) Что такое Bearer?](#50-что-такое-bearer)
  * [51) Что такое Eloquent ORM, для чего используется, какие типы связи есть?](#51-что-такое-eloquent-orm-для-чего-используется-какие-типы-связи-есть)
  * [52) Что такое SQL инъекции?](#52-что-такое-sql-инъекции)
  * [53) ORM защищает от SQL инъекций? Или все равно можно получить несанкционированый доступ?](#53-orm-защищает-от-sql-инъекций-или-все-равно-можно-получить-несанкционированый-доступ)
  * [54) Что такое Job в Laravel, для чего они нужны, как они работают, кто их запускает?](#54-что-такое-job-в-laravel-для-чего-они-нужны-как-они-работают-кто-их-запускает)
  * [55) Какой инструмент в Laravel управляет этими очередями?](#55-какой-инструмент-в-laravel-управляет-этими-очередями)
  * [56) Что такое Supervisor?](#56-что-такое-supervisor)
  * [57) Сколько Worker можно запустить на 1 задачу? Для чего это делается?](#57-сколько-worker-можно-запустить-на-1-задачу-для-чего-это-делается)
  * [58) Где хранятся настройки Laravel?](#58-где-хранятся-настройки-laravel)
  * [59) Какие минусы могут возникнуть при использовании обсервера в контроллере? Например в Post при привязке тегов?](#59-какие-минусы-могут-возникнуть-при-использовании-обсервера-в-контроллере-например-в-post-при-привязке-тегов)
  * [60) Если после изменения роутинга, перестал работать проект, какие команды рекомендуется использовать в Laravel?](#60-если-после-изменения-роутинга-перестал-работать-проект-какие-команды-рекомендуется-использовать-в-laravel)
  * [61) Вопрос по гиту, предположим начинаем свою ветку переносить в мастер, и появился конфликт, какие наши первые действия?](#61-вопрос-по-гиту-предположим-начинаем-свою-ветку-переносить-в-мастер-и-появился-конфликт-какие-наши-первые-действия)
  * [62) Что такое чери пик?](#62-что-такое-чери-пик)
  * [63) Чем отличается git merge от git rebase?](#63-чем-отличается-git-merge-от-git-rebase)
  * [64) Как работает команда git reset?](#64-как-работает-команда-git-reset)
  * [65) Что такое моковое тестирование, и область его применения?](#65-что-такое-моковое-тестирование-и-область-его-применения)
    * [Области применения:](#области-применения)
    * [Когда НЕ использовать моки:](#когда-не-использовать-моки)
  * [65) Какая проблема может возникнуть с моками при тестировании интерфейсов?](#65-какая-проблема-может-возникнуть-с-моками-при-тестировании-интерфейсов)
    * [Как это лечится?](#как-это-лечится)
  * [66) Паттерны проектирования, на какие категории делятся, и какие и где активно используются?](#66-паттерны-проектирования-на-какие-категории-делятся-и-какие-и-где-активно-используются)
    * [Порождающие (Creational) - создание объектов](#порождающие-creational---создание-объектов)
      * [Singleton (Одиночка)](#singleton-одиночка)
      * [Factory Method (Фабричный метод)](#factory-method-фабричный-метод)
      * [Builder (Строитель)](#builder-строитель)
      * [Abstract Factory - создает семейства связанных объектов](#abstract-factory---создает-семейства-связанных-объектов)
      * [Prototype - клонирование существующих объектов](#prototype---клонирование-существующих-объектов)
    * [Структурные (Structural) - композиция объектов](#структурные-structural---композиция-объектов)
    * [Adapter (Адаптер)](#adapter-адаптер)
      * [Facade (Фасад)](#facade-фасад)
      * [Decorator (Декоратор/Обертка)](#decorator-декораторобертка)
      * [Composite - древовидные структуры объектов](#composite---древовидные-структуры-объектов)
      * [Proxy - контроль доступа к объекту](#proxy---контроль-доступа-к-объекту)
    * [Поведенческие (Behavioral)](#поведенческие-behavioral)
      * [Observer (Наблюдатель)](#observer-наблюдатель)
      * [Strategy (Стратегия)](#strategy-стратегия)
      * [Iterator (Итератор)](#iterator-итератор)
      * [Command - инкапсуляция запросов как объектов](#command---инкапсуляция-запросов-как-объектов)
  * [67) Движки БД MYSQL, какие есть, в чем отличие, на что нужно обращать внимание](#67-движки-бд-mysql-какие-есть-в-чем-отличие-на-что-нужно-обращать-внимание)
    * [MyISAM (устаревший, но встречается)](#myisam-устаревший-но-встречается)
    * [InnoDB (стандарт с MySQL 5.5+)](#innodb-стандарт-с-mysql-55)
  * [68) Блокировки в БД, оптимистичные и пессимистичные, что это и что нужно знать?](#68-блокировки-в-бд-оптимистичные-и-пессимистичные-что-это-и-что-нужно-знать)
    * [Пессимистичные блокировки (Pessimistic Locking)](#пессимистичные-блокировки-pessimistic-locking)
    * [Оптимистичные блокировки (Optimistic Locking)](#оптимистичные-блокировки-optimistic-locking)
  * [69) Что такое Deadlock и как его избежать?](#69-что-такое-deadlock-и-как-его-избежать)
    * [Способы избежать deadlock:](#способы-избежать-deadlock)
      * [Единый порядок блокировки](#единый-порядок-блокировки)
      * [Короткие транзакции](#короткие-транзакции)
      * [Использование таймаутов/retry](#использование-таймаутовretry)
      * [Избегание ненужных блокировок](#избегание-ненужных-блокировок)
      * [Использование пессимистичных блокировок с умом](#использование-пессимистичных-блокировок-с-умом)
  * [70) Уровни изоляции БД](#70-уровни-изоляции-бд)
    * [4 стандартных уровня изоляции (от слабого к строгому):](#4-стандартных-уровня-изоляции-от-слабого-к-строгому)
      * [1 - Read Uncommitted (Чтение незафиксированных данных)](#1---read-uncommitted-чтение-незафиксированных-данных)
      * [2 - Read Committed (Чтение зафиксированных данных)](#2---read-committed-чтение-зафиксированных-данных)
      * [3 - Repeatable Read (Повторяемое чтение)](#3---repeatable-read-повторяемое-чтение)
      * [4 - Serializable (Сериализуемый)](#4---serializable-сериализуемый)
    * [Уровни изоляции в разных СУБД:](#уровни-изоляции-в-разных-субд)
    * [Как выбрать уровень изоляции:](#как-выбрать-уровень-изоляции)
  * [71) Оператор DISTINCT в SQL - что это и зачем применять?](#71-оператор-distinct-в-sql---что-это-и-зачем-применять)
    * [Синтаксис и варианты использования:](#синтаксис-и-варианты-использования)
    * [Важные особенности DISTINCT:](#важные-особенности-distinct)
      * [Производительность](#производительность)
      * [Работа с NULL значениями](#работа-с-null-значениями)
      * [С агрегатными функциями](#с-агрегатными-функциями)
    * [Когда использовать DISTINCT:](#когда-использовать-distinct)
* [Отдельный раздел, который нужно будет объединить с основным и разбить на подразделы](#отдельный-раздел-который-нужно-будет-объединить-с-основным-и-разбить-на-подразделы)
  * [Какой основной протокол интернета?](#какой-основной-протокол-интернета)
  * [Какие есть версии HTTP протокола? Какие их отличия?](#какие-есть-версии-http-протокола-какие-их-отличия)
    * [Ключевые отличия между версиями HTTP:](#ключевые-отличия-между-версиями-http)
      * [HTTP/1.1 vs HTTP/2:](#http11-vs-http2)
      * [HTTP/2 vs HTTP/3:](#http2-vs-http3)
    * [Какой протокол под HTTP?](#какой-протокол-под-http)
      * [Классика (HTTP/1.1 и HTTP/2):](#классика-http11-и-http2)
      * [Новая школа (HTTP/3):](#новая-школа-http3)
  * [Директива DECLARE в контексте PHP, что это и зачем?](#директива-declare-в-контексте-php-что-это-и-зачем)
    * [declare(strict_types=1)](#declarestrict_types1)
    * [declare(ticks=1);](#declareticks1)
    * [declare(encoding='...');](#declareencoding)
    * [Область действия DECLARE в PHP:](#область-действия-declare-в-php)
  * [Директивы REQUIRE/INCLUDE](#директивы-requireinclude)
    * [Основные различия:](#основные-различия)
  * [Файлы Composer - composer.json/composer.lock](#файлы-composer---composerjsoncomposerlock)
  * [Позднее статическое связывание (Late Static Binding)](#позднее-статическое-связывание-late-static-binding)
  * [Механизм передачи данных в PHP. Copy-on-write](#механизм-передачи-данных-в-php-copy-on-write)
  * [PSR (PHP Standard Recommendations)](#psr-php-standard-recommendations)
    * [Основные PSR:](#основные-psr)
      * [PSR-4](#psr-4)
  * [SOLID](#solid)
    * [Single Responsibility Principle (Принцип единой ответственности)](#single-responsibility-principle-принцип-единой-ответственности)
    * [Open-Closed Principle (Принцип Открытости/Закрытости)](#open-closed-principle-принцип-открытостизакрытости)
    * [Liskov Substitution Principle](#liskov-substitution-principle)
    * [Interface Segregation Principle](#interface-segregation-principle)
    * [Dependency Inversion Principle](#dependency-inversion-principle)
  * [REST API](#rest-api)
    * [Хороший REST API:](#хороший-rest-api)
    * [Плохой REST API:](#плохой-rest-api)
  * [CORS (Cross-Origin Resource Sharing)](#cors-cross-origin-resource-sharing)
    * [Проблема, которую решает:](#проблема-которую-решает)
    * [Как работает CORS:](#как-работает-cors)
  * [Тестирование](#тестирование)
    * [Unit (Модульные) тесты](#unit-модульные-тесты)
    * [Integration (Интеграционные) тесты](#integration-интеграционные-тесты)
    * [3. Feature (Функциональные) тесты](#3-feature-функциональные-тесты)
    * [Моки внешних HTTP-запросов:](#моки-внешних-http-запросов)
    * [Практика в Laravel:](#практика-в-laravel)
    * [Ключевое правило для запоминания:](#ключевое-правило-для-запоминания)
  * [Active Record / Data Mapper](#active-record--data-mapper)
    * [Active Record (Laravel / Eloquent ORM)](#active-record-laravel--eloquent-orm)
    * [Data Mapper (Symfony / Doctrine ORM)](#data-mapper-symfony--doctrine-orm)
  * [Logger (Логгеры) в PHP](#logger-логгеры-в-php)
    * [Базовое понятие](#базовое-понятие)
    * [PSR-3 (стандарт)](#psr-3-стандарт)
    * [Symfony (Monolog)](#symfony-monolog)
    * [Laravel (тоже Monolog, но проще)](#laravel-тоже-monolog-но-проще)
    * [Паттерны в логгерах](#паттерны-в-логгерах)
  * [Валидация в Laravel vs Symfony](#валидация-в-laravel-vs-symfony)
    * [LARAVEL: Валидация](#laravel-валидация)
      * [Основные способы](#основные-способы)
      * [Правила валидации (часто используемые)](#правила-валидации-часто-используемые)
      * [Кастомные правила](#кастомные-правила)
      * [Валидация массивов](#валидация-массивов)
      * [Условная валидация](#условная-валидация)
      * [Валидация после нормализации](#валидация-после-нормализации)
    * [SYMFONY: Валидация](#symfony-валидация)
      * [Базовые концепции](#базовые-концепции)
      * [Основные способы валидации](#основные-способы-валидации)
      * [Процесс валидации](#процесс-валидации)
      * [Form Request в Symfony (аналог Laravel)](#form-request-в-symfony-аналог-laravel)
      * [Кастомные валидаторы](#кастомные-валидаторы)
      * [Группы валидации](#группы-валидации)
      * [Последовательная валидация](#последовательная-валидация)
    * [СРАВНЕНИЕ Laravel vs Symfony](#сравнение-laravel-vs-symfony)
    * [ЧТО ГОВОРИТЬ НА СОБЕСЕДОВАНИИ](#что-говорить-на-собеседовании-1)
  * [SQL - UNION vs UNION ALL](#sql---union-vs-union-all)
    * [Базовое определение](#базовое-определение)
    * [Синтаксис](#синтаксис)
    * [Ключевые различия](#ключевые-различия-1)
    * [Важные особенности](#важные-особенности)
    * [UNION vs JOIN - в чем разница?](#union-vs-join---в-чем-разница)
    * [Резюме](#резюме-2)
  * [Хинты для индексов в MySQL: USE INDEX, FORCE INDEX, IGNORE INDEX](#хинты-для-индексов-в-mysql-use-index-force-index-ignore-index)
    * [USE INDEX — рекомендация](#use-index--рекомендация)
    * [FORCE INDEX — принуждение](#force-index--принуждение)
    * [IGNORE INDEX — игнорирование](#ignore-index--игнорирование)
    * [FOR vs USE — ключевое различие](#for-vs-use--ключевое-различие)
    * [Практические примеры](#практические-примеры)
    * [Когда НЕ использовать хинты](#когда-не-использовать-хинты)
    * [Резюме](#резюме-3)
  * [Event Loop и жизненный цикл JavaScript](#event-loop-и-жизненный-цикл-javascript)
    * [Базовая модель (как устроен Event Loop)](#базовая-модель-как-устроен-event-loop)
    * [Ключевые термины](#ключевые-термины)
    * [Пример](#пример)
    * [Резюме](#резюме-4)
  * [Браузерные API](#браузерные-api)
    * [Media API (Video/Audio)](#media-api-videoaudio)
    * [Storage API (Хранение данных)](#storage-api-хранение-данных)
    * [Network API (Сеть)](#network-api-сеть)
    * [Резюме](#резюме-5)
  * [Аутентификация / Авторизация (Authentication / Authorization)](#аутентификация--авторизация-authentication--authorization)
    * [Stateful (с состоянием) — Session-based Authentication](#stateful-с-состоянием--session-based-authentication)
    * [Stateless (без состояния) — Token-based Authentication](#stateless-без-состояния--token-based-authentication)
    * [OAuth 2.0 / OpenID Connect (стандарт для делегирования доступа)](#oauth-20--openid-connect-стандарт-для-делегирования-доступа)
    * [Резюме](#резюме-6)
  * [DTO (Data Transfer Object)](#dto-data-transfer-object)
    * [Область применения](#область-применения)
    * [Практический пример в Laravel](#практический-пример-в-laravel)
    * [DTO vs Другие объекты](#dto-vs-другие-объекты)
    * [Когда НЕ нужно использовать DTO](#когда-не-нужно-использовать-dto)
    * [Резюме](#резюме-7)
  * [Трейты (Trait) / Абстрактные классы (Abstract Class) / Интерфейсы (Interface)](#трейты-trait--абстрактные-классы-abstract-class--интерфейсы-interface)
    * [Трейт (Trait): "Кусок кода для повторного использования"](#трейт-trait-кусок-кода-для-повторного-использования)
    * [Абстрактный класс: "Частично готовый шаблон"](#абстрактный-класс-частично-готовый-шаблон)
    * [Интерфейс: "Контракт на реализацию"](#интерфейс-контракт-на-реализацию)
    * [Практические правила: Что выбрать?](#практические-правила-что-выбрать)
    * [Важные нюансы и примеры из Laravel](#важные-нюансы-и-примеры-из-laravel)
    * [Резюме](#резюме-8)
<!-- TOC -->

## 1) Какие типы данных существуют в PHP?
- **Скалярные**: bool, int, float, string

- **Составные**: array, object, callable, iterable

- **Специальные**: resource, null, Enum

- **Псевдотипы**: mixed, void, never

## 2) Расскажи мне про callable подробнее:
```php
// Функция
$func = 'strlen';

// Метод объекта
$callable = [$object, 'methodName'];

// Статический метод
$staticCallable = ['ClassName', 'staticMethod'];
```

## 3) Enum это тип данных?
**Enum (перечисление)** — это специальный тип данных, который представляет собой ограниченный набор именованных значений. В PHP, начиная с версии 8.1, Enums реализованы как особый вид классов.

## 4) Что такое замыкание в PHP?
**Замыкание (Closure)** в PHP — это особый вид анонимной функции (функции без имени), которая обладает "памятью": она способна захватывать и получать доступ к переменным из той области видимости, в которой была создана, даже после того, как эта родительская область видимости перестала существовать.

## 5) Чем отличается замыкание от обычной функции?
Главное отличие замыкания от обычной функции в PHP заключается в области видимости переменных (scope) и способности захватывать эти переменные. А также именование и объявление.

## 6) Какая область видимости переменных у функции замыкания?
Область видимости переменных у функции замыкания — это двойная (или комбинированная) область видимости.

## 7) Чем отличается статическое замыкание от обычного замыкания?
Статическое замыкание не имеет доступа к `$this`, не привязано к объекту-контексту, нельзя перепривязать. НЕ держит ссылку на объект, поэтому легковесное, и может быть удален сборщиком мусора (Предотвращает утечки памяти). Лучше для утилитарных функций.

## 8) Почему статическое быстрее, а обычное помедленнее?
Потому что оно не выполняет логику связывания с объектом и, следовательно, требует меньше шагов для выполнения

## 9) Что такое сборщик мусора?
**Сборщик мусора (Garbage Collector, GC)** — это механизм в языках программирования с автоматическим управлением памятью (таких как PHP, Java, Python), который автоматически находит и удаляет объекты или данные, которые больше не используются приложением.

**Его основная задача** — освобождать оперативную память, чтобы предотвратить её переполнение (утечки памяти) и сделать процесс разработки более простым.

## 10) Какие виды ссылок есть в PHP?
- **Жесткие ссылки (&)** - прямое связывание переменных
- **Ссылки на объекты** - объекты всегда передаются по ссылке
- **Символические ссылки ($$var)** - динамические имена переменных
- **Ссылки в функциях** - изменение переданных параметров
- **Ссылки в массивах** - изменение элементов при переборе
- **Callable ссылки** - ссылки на функции и методы
- **Ссылки в замыканиях** - захват переменных по ссылке

## 11) Что такое stdClass() ?
**stdClass** — это специальный, встроенный класс в PHP, который служит базовым, анонимным (или пустым) контейнером для данных. Он не имеет никаких методов, определённых пользователем, и по сути является эквивалентом универсального, безымянного объекта.

## 12) Что такое переменная переменной? Для чего и где это используется?
**Переменная переменной** — это переменная, имя которой динамически определяется значением другой переменной. `($$)`.

## 13) Что такое рекурсия?
**Рекурсия (Recursion)** — это метод в программировании, при котором функция вызывает саму себя непосредственно или опосредованно (через другую функцию) для решения задачи.

## 14) Что происходит при бесконечной рекурсии?
При бесконечной рекурсии происходит переполнение стека **(Stack Overflow)**, что в итоге приводит к аварийному завершению (остановке) выполнения скрипта PHP.

## 15) Основные отличия интерфейса от абстрактного класса?
**Интерфейс** 
 - Только контракт (методы без тела)
 - Методы только `public`
 - Не может иметь свойств (только константы)
 - Класс может реализовать много интерфейсов
 - Используется для описания что класс должен уметь делать

**Абстрактный класс** 
 - Может содержать и контракт, и готовую реализацию
 - Методы могут быть `public/protected/private`
 - Может иметь любые свойства
 - Класс может наследовать только один абстрактный класс
 - Используется для описания общего поведения и структуры

## 16) Для чего нужны сессии и где они хранятся?
**Сессии** — это механизм для сохранения данных между разными запросами от одного пользователя. Они позволяют **"помнить"** состояние пользователя при переходе между страницами.

**Сессии нужны для:** 
 - Сохранения состояния между запросами
 - Аутентификации и авторизации
 - Корзин покупок
 - Многошаговых форм
 - Пользовательских настроек

**Где хранятся:** На сервере хранятся файлы 
 - **Файлы** - по умолчанию
 - **База данных** - для кластеров и больших проектов
 - **Redis/Memcached** - для высокой производительности)
 - У клиента хранится `cookie` с `PHPSESSID`, которая автоматически передается на сервер

## 17) Транзакции в базах данных
**Транзакция** — это последовательность операций с базой данных, которая выполняется как единое целое по принципу "всё или ничего" (all-or-nothing)
```sql
-- Пример: перевод денег между счетами
START TRANSACTION;
  UPDATE accounts SET balance = balance - 100 WHERE id = 1;  -- списание
  UPDATE accounts SET balance = balance + 100 WHERE id = 2;  -- зачисление
COMMIT;
-- Если что-то пошло не так: ROLLBACK;
```

### Свойства ACID (основа транзакций)
**A — Atomicity (Атомарность)**
* Все операции транзакции выполняются или не выполняется ни одна
* Даже при сбое системы (откат при ошибке)

**C — Consistency (Согласованность)**
* Транзакция переводит БД из одного согласованного состояния в другое
* Сохраняются все ограничения (foreign keys, unique, check constraints)

**I — Isolation (Изолированность)**
* Параллельные транзакции не влияют друг на друга
* Существуют уровни изоляции с разной степенью "видимости" изменений

**D — Durability (Долговечность)**
* После COMMIT изменения сохраняются даже при сбое системы

### Проблемы параллельных транзакций
**Проблема 1: Грязное чтение (Dirty Read)** — чтение незафиксированных данных, которые могут быть откачены
```sql
-- Транзакция 1: Администратор исправляет цену товара
START TRANSACTION;
UPDATE products SET price = 1000 WHERE id = 1;  -- Была 500
-- Но не COMMIT ещё, думает, проверяет...

-- Транзакция 2: Покупатель видит эту цену
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SELECT price FROM products WHERE id = 1;  -- Видит 1000!
-- Покупатель: "Ой, дорого!" уходит

-- Транзакция 1: Администратор передумал
ROLLBACK;  -- Цена снова 500
-- Но покупатель уже ушёл!
```
**Решение**: Использовать `READ COMMITTED` или выше.

**Проблема 2: Неповторяемое чтение (Non-repeatable Read)** — два чтения одного объекта дают разные результаты (изменение **СУЩЕСТВУЮЩЕЙ** строки)
```sql
-- Банковское приложение: проверка баланса перед операциями
START TRANSACTION;
-- 1. Проверяем баланс
SELECT balance FROM accounts WHERE user_id = 1;  -- 1000

-- В это время другая транзакция:
START TRANSACTION;
UPDATE accounts SET balance = balance - 500 WHERE user_id = 1;
COMMIT;  -- Теперь баланс 500

-- 2. Снова проверяем (в той же транзакции)
SELECT balance FROM accounts WHERE user_id = 1;  -- Уже 500!
-- Логика нарушена: баланс изменился между двумя чтениями
```
**Решение**: Использовать `REPEATABLE READ` или выше.

**Проблема 3: Фантомное чтение (Phantom Read)** — появление **НОВЫХ** строк между двумя чтениями
```sql
-- Отчёт о количестве заказов за день
START TRANSACTION;
-- 1. Считаем заказы
SELECT COUNT(*) FROM orders WHERE date = '2024-01-01';  -- 100

-- В это время клиент делает новый заказ
START TRANSACTION;
INSERT INTO orders (date, amount) VALUES ('2024-01-01', 5000);
COMMIT;

-- 2. Считаем сумму заказов
SELECT SUM(amount) FROM orders WHERE date = '2024-01-01';
-- Сумма учитывает 101-й заказ, а COUNT показывал 100
-- Несоответствие в отчёте!
```
**Решение**: Использовать `SERIALIZABLE`.

### Уровни изоляции (от слабого к строгому)
**1. READ UNCOMMITTED (чтение незафиксированных данных)**
```sql
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
```
* Можно читать незавершённые изменения других транзакций
* Проблема: Грязное чтение (Dirty Read)

**2. READ COMMITTED (чтение фиксированных данных) — DEFAULT в PostgresSQL**
```sql
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```
* Видны только зафиксированные изменения
* Проблема: Неповторяемое чтение (Non-repeatable Read)

**3. REPEATABLE READ (повторяемое чтение) — DEFAULT в MySQL**
```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```
* Гарантирует, что данные, прочитанные в начале транзакции, не изменятся
* Проблема: Фантомное чтение (Phantom Read)

**4. SERIALIZABLE (сериализуемый)**
```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```
* Полная изоляция, как будто транзакции выполняются последовательно
* Самый медленный, но нет проблем параллельного доступа

### Управление транзакциями в MySQL
```sql
-- Явное начало
START TRANSACTION;
-- или
BEGIN;

-- Операции
INSERT INTO orders ...;
UPDATE accounts ...;

-- Завершение
COMMIT;     -- подтвердить изменения
ROLLBACK;   -- откатить изменения

-- Установка уровня изоляции
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

### Транзакции в Laravel
```php
// Способ 1: Автоматическая обработка
DB::transaction(function () {
    $user = User::create($data);
    $user->orders()->create($orderData);
    // Если возникнет исключение - произойдёт автоматический ROLLBACK
});

// Способ 2: Ручное управление
DB::beginTransaction();
try {
    $user = User::create($data);
    $user->orders()->create($orderData);
    DB::commit();
} catch (Exception $e) {
    DB::rollback();
    throw $e;
}

// Способ 3: С указанием количества попыток (для deadlock)
DB::transaction(function () {
    // операции
}, 3); // 3 попытки
```

### Резюме
Транзакции обеспечивают атомарность, согласованность, изолированность и долговечность операций (ACID). Они критически важны для операций, которые должны быть выполнены полностью или не выполнены вообще, например, перевод денег или создание заказа.

В MySQL InnoDB используется уровень изоляции REPEATABLE READ по умолчанию. При работе с транзакциями важно понимать проблемы параллельного доступа: грязное чтение, неповторяемое чтение и фантомное чтение.

В Laravel транзакции реализуются через `DB::transaction()`, который автоматически обрабатывает commit и rollback при исключениях. Для сложных сценариев можно использовать ручное управление через `beginTransaction()`, `commit()`, `rollback()`.
```sql
ACID:
- Atomicity: всё или ничего
- Consistency: целостность данных
- Isolation: параллельные транзакции не мешают
- Durability: изменения сохраняются

Уровни изоляции (от слабого к строгому):
1. READ UNCOMMITTED — грязное чтение
2. READ COMMITTED — неповторяемое чтение  
3. REPEATABLE READ — фантомное чтение
4. SERIALIZABLE — полная изоляция

Команды:
- START TRANSACTION / BEGIN
- COMMIT
- ROLLBACK
- SAVEPOINT / ROLLBACK TO SAVEPOINT

В Laravel:
- DB::transaction(callback)
- DB::beginTransaction() / commit() / rollback()
```


## 18) Что такое обфускатор и как его реализовать?
**Обфускация** — это процесс «запутывания» исходного кода, чтобы его было сложно читать и анализировать.

Код работает так же, как и до обфускации, но для человека становится непонятным.

**Используется**:
- для защиты коммерческих приложений (чтобы сложнее было украсть логику);
- для защиты от реверс-инжиниринга;
- иногда — чтобы спрятать лицензионные проверки, ключи и т. д.

**Основные техники**:
- Переименование переменных, функций, классов `preg_replace()`
- Удаление комментариев и форматирования `preg_replace()`, `trim()`
- Шифрование строковых литералов `base64_encode/base64_decode`
- Добавление ложного кода (fake)
- Динамическое выполнение `eval`, `call_user_func`

## 19) Что такое идемпотентность?
**Идемпотентность** — это свойство операции или метода, которое означает, что многократное выполнение этой операции с одинаковыми входными данными приводит к тому же самому результату (или состоянию системы), как если бы операция была выполнена только один раз.

- Идемпотентность = повторение операции не меняет результат.
- В коде: присвоение значения переменной.
- В API: GET, PUT, DELETE → идемпотентные, POST, PATCH → нет.

**Идемпотентность** — это критически важное свойство для:
- Надежных API - защита от дублирующих запросов
- Распределенных систем - безопасные retry механизмы
- Очередей сообщений - обработка дубликатов сообщений
- Финансовых операций - предотвращение двойных списаний

## 20) Какие бывают области видимости у переменных?
- **Локальная** - внутри функций, уничтожается после выполнения
- **Глобальная** - доступна везде в скрипте `global`, `$GLOBALS`
- **Статическая** - сохраняет значение между вызовами функции `static`
- **Public** - доступна отовсюду (классы)
- **Protected** - доступна в классе и наследниках
- **Private** - доступна только в объявляющем классе
- **Замыкания** - захватывают переменные из внешней области `use`

## 21) Какие коды HTTP ответов бывают, и на какие группы они разделяются?
**1xx: Информационные (Informational)**
- 100 Continue — сервер принял заголовки, можно отправлять тело запроса.
- 101 Switching Protocols — переключение протоколов (например, на WebSocket).

**2xx: Успех (Success)**
- 200 OK — всё хорошо, стандартный успешный ответ. (GET, PATCH, DELETE)
- 201 Created — ресурс успешно создан (часто при POST).
- 204 No Content — успешно, но без тела ответа (например, при DELETE иногда PUT).

**3xx: Перенаправление (Redirection)**
- 301 Moved Permanently — постоянный редирект.
- 302 Found — временный редирект.
- 304 Not Modified — ресурс не изменился (используется при кешировании).

**4xx: Ошибка клиента (Client Error)**
- 400 Bad Request — некорректный запрос. Неправильное тело запроса, невалидные данные, корявая структура JSON
- 401 Unauthorized — нужна авторизация. Запрос без авторизации или с неправильным токеном.
- 403 Forbidden — доступ запрещён, даже если авторизован (нет прав)
- 404 Not Found — ресурс не найден.
- 409 Conflict - ресурс конфликтует с текущим состоянием (например, пытаешься создать пользователя с email, который уже существует)
- 422 Unprocessable Entity — сервер понял запрос, но не может обработать (Ошибка валидации. JSON синтаксически верный, но поле email пустое или пароль короткий).
- 429 Too Many Requests - превышен лимит запросов (Rate Limiting).

**5xx: Ошибка сервера (Server Error)**
- 500 Internal Server Error — общая ошибка сервера (Сервер сдох. Апокалипсис. Логируй и чини.)
- 502 Bad Gateway — неверный ответ от прокси/шлюза.
- 503 Service Unavailable — сервис временно недоступен (например, перегрузка).
- 504 Gateway Timeout — шлюз не дождался ответа.

## 22) Какие методы HTTP запросов бывают?
**GET**
- Назначение: получить ресурс(ы).
- Тело запроса обычно не используется.
- Safe (должен только читать), идемпотентен.

**POST**
- Назначение: создать ресурс или выполнить действие.
- Обычно содержит тело (form/json).
- Не идемпотентен (каждый вызов может создать новый ресурс).

**PUT**
- Назначение: замена ресурса целиком (или создание по указанному URI).
- Обычно идемпотентен: повторные вызовы дают тот же результат.

**PATCH**
- Назначение: частичное обновление ресурса (patch — "заплатка").
- Может быть идемпотентен, но не обязателен — зависит от реализации.

**DELETE**
- Назначение: удалить ресурс.
- Обычно идемпотентен: удалить уже удалённый ресурс — результат тот же (ошибка/пустой ответ).

**HEAD**
- То же, что GET, но без тела ответа — только заголовки (используется для проверки наличия ресурса, кеширования).
- Safe, идемпотентен.

**OPTIONS**
- Возвращает, какие методы поддерживаются на данном ресурсе (CORS/policy часто используют).
- Safe, идемпотентен.

**CONNECT** — устанавливает туннель (обычно для прокси/HTTPS).

**TRACE** — эхо-запрос (диагностика) — редко и обычно блокируется (опасно).

## 23) Какие виды JOIN бывают в SQL?
- INNER JOIN
- LEFT JOIN (LEFT OUTER JOIN)
- RIGHT JOIN (RIGHT OUTER JOIN)
- FULL OUTER JOIN
- CROSS JOIN

## 24) Чем отличается LEFT от RIGHT JOIN?
Какая таблица будет главная левая (FROM) или правая (JOIN))

## 25) Какие агрегатные функции есть в SQL?
```sql
COUNT();
SUM();
AVG();
MIN()/MAX();
STRING_AGG();
ARRAY_AGG();
```
## 26) SQL - Разница WHERE vs HAVING 
### WHERE
**WHERE** — фильтрует строки **ДО** группировки
```sql
-- WHERE работает с отдельными строками
SELECT department, COUNT(*) as emp_count
FROM employees
WHERE salary > 50000  -- фильтруем строки ДО группировки
GROUP BY department;
```

### HAVING
**HAVING** — фильтрует результаты **ПОСЛЕ** группировки
```sql
-- HAVING работает с агрегированными результатами
SELECT department, COUNT(*) as emp_count
FROM employees
GROUP BY department
HAVING COUNT(*) > 10;  -- фильтруем после группировки
```

### Ключевые различия
| Критерий                               | WHERE                         | HAVING                                     |
|----------------------------------------|-------------------------------|--------------------------------------------|
| Когда применяется                      | До группировки (GROUP BY)     | После группировки (GROUP BY)               |
| С чем работает                         | С отдельными строками таблицы | С результатами агрегации (COUNT, SUM, AVG) |
| Можно использовать агрегатные функции? | ❌ НЕТ                         | ✅ ДА                                       |
| Порядок в запросе                      | После FROM, до GROUP BY       | После GROUP BY, до ORDER BY                |

### Пример с обоими условиями
```sql
SELECT 
    department,
    AVG(salary) as avg_salary,
    COUNT(*) as emp_count
FROM employees
WHERE hire_date > '2020-01-01'  -- берем только новых сотрудников
GROUP BY department
HAVING AVG(salary) > 70000      -- отделы со средней з/п > 70к
ORDER BY avg_salary DESC;       -- сортируем по убыванию з/п
```
**Порядок выполнения SQL-запроса:**
1. **FROM** - выбор таблицы
2. **WHERE** - фильтрация строк
3. **GROUP BY** - группировка
4. **HAVING** - фильтрация групп
5. **SELECT** - выбор полей
6. **ORDER BY** - сортировка
7. **LIMIT** - ограничение результатов

### Частые ошибки
```sql
-- ❌ НЕРАБОТАЕТ: WHERE с агрегатной функцией
SELECT department, COUNT(*) 
FROM employees
WHERE COUNT(*) > 10  -- ОШИБКА!
GROUP BY department;

-- ✅ РАБОТАЕТ: то же самое с HAVING
SELECT department, COUNT(*) 
FROM employees
GROUP BY department
HAVING COUNT(*) > 10;  -- ПРАВИЛЬНО
```

### Практическое правило
* Используй **WHERE**, когда фильтруешь по значениям в отдельных строках
* Используй **HAVING**, когда фильтруешь по результатам группировки (COUNT, SUM, AVG, MIN, MAX)

### Что говорить на собеседовании
WHERE фильтрует строки до группировки, а HAVING — после. WHERE нельзя использовать с агрегатными функциями, а HAVING — можно. 

Например, если нужно найти отделы с более чем 10 сотрудниками — это HAVING, а если найти сотрудников с зарплатой больше 50к — это WHERE.

## 27) Индексы в базах данных
**Индекс** — это отсортированный указатель на данные в таблице, как алфавитный указатель в книге. Без индекса СУБД приходится делать полный перебор **(full scan)** всех строк.
```sql
-- Без индекса: проверяет ВСЕ 1,000,000 строк
SELECT * FROM users WHERE email = 'test@example.com';

-- С индексом по email: находит за 2-3 шага
CREATE INDEX idx_email ON users(email);
SELECT * FROM users WHERE email = 'test@example.com';
```

### Зачем нужны индексы?
1. Ускорение поиска (WHERE, JOIN)
2. Ускорение сортировки (ORDER BY)
3. Обеспечение уникальности (UNIQUE INDEX)
4. Оптимизация группировки (GROUP BY)
5. Внешние ключи (FOREIGN KEY) требуют индексов

### Типы индексов по структуре хранения
#### B-Tree (B+Tree) — самый распространённый
**B-tree** — это сбалансированное дерево поиска

**Как работает:**
Представь книгу с **оглавлением**. Чтобы найти главу про "DTO", ты не листаешь всю книгу, а смотришь в оглавление, которое отсортировано по алфавиту. B-tree — это многоуровневое оглавление для данных в БД.

**Структура:**
```text
        [P]
      /     \
   [J]       [T]
  / | \     / | \
[A-C] [L] [R] [V-Z]
```
* **Узлы (ноды)** содержат ключи и указатели.
* **Ключи отсортированы** внутри узла.
* Дерево **сбалансировано** — все ветви имеют примерно одинаковую глубину.

**Поиск O(log n):**

Чтобы найти "K":
1. Корень `[P]`: K < P → идём в левую ветвь.
2. Узел `[J]`: K > J → идём во вторую подветвь.
3. Лист `[K, L]` — нашли

**Ключевые свойства:**
* **Диапазонные запросы (range queries)**: Идеален для `WHERE age BETWEEN 20 AND 30`, `WHERE name LIKE 'A%'`.
* **Сортировка:** Данные в листьях уже отсортированы → `ORDER BY` выполняется быстро.
* **Многоуровневость:** Высота дерева растёт логарифмически. Для 1 млн записей нужно всего 3-4 шага.

**Пример в MySQL (InnoDB):**
```sql
-- InnoDB использует B+tree (разновидность B-tree)
CREATE INDEX idx_users_email ON users(email);

-- Быстро: диапазонный запрос
SELECT * FROM users WHERE email BETWEEN 'a' AND 'b';
-- Быстро: сортировка
SELECT * FROM users ORDER BY email;
```

#### Hash индекс (Хэш-таблица)
**Как работает:**

Представь **ящик с пронумерованными коробками**. Чтобы найти "DTO", ты вычисляешь номер коробки через хэш-функцию `hash("DTO") = 42` и сразу идёшь к коробке №42.

**Структура:**
```text
Хэш-таблица:
[0] → NULL
[1] → "Array"
[42] → "DTO"  ← hash("DTO") = 42
[100] → "Class"
```

**Поиск O(1) в среднем:**
1. Вычислить хэш ключа.
2. Перейти по адресу.
3. Сравнить ключ (на случай коллизий).

**Ключевые свойства:**
* **Точечные запросы (point lookup):** Идеален для `WHERE id = 123`, `WHERE email = 'exact@mail.com'`.
* **НЕТ диапазонных запросов:** `WHERE age > 20` — невозможно, так как хэши не сохраняют порядок.
* **Коллизии:** Разные ключи могут давать одинаковый хэш → нужна обработка (цепочки, открытая адресация).
* **НЕТ сортировки:** Данные разбросаны случайно → `ORDER BY` требует полного сканирования.

**Пример в MySQL (Memory Engine):**
```sql
-- Только для точного совпадения
CREATE INDEX idx_hash USING HASH ON users(email);

-- Молниеносно:
SELECT * FROM users WHERE email = 'exact@mail.com';

-- НЕ РАБОТАЕТ для диапазонов:
SELECT * FROM users WHERE email > 'a'; -- Полное сканирование таблицы!
```

##### Сравнительная таблица: B-tree vs Hash

| Критерий                                               | B-tree индекс              | Hash индекс                        |
|--------------------------------------------------------|----------------------------|------------------------------------|
| Скорость поиска                                        | O(log n) — быстро          | O(1) в среднем — очень быстро      |
| Диапазонные запросы (`>`, `<`, `BETWEEN`, `LIKE 'A%'`) | ✅ Отлично                  | ❌ Невозможно                       |
| Сортировка (`ORDER BY`)                                | ✅ Данные уже отсортированы | ❌ Требует полного сканирования     |
| Точное совпадение (`=`)                                | ✅ Быстро                   | ✅ Экстремально быстро              |
| Использование памяти                                   | Умеренное                  | Зависит от коэффициента заполнения |
| Коллизии                                               | Нет                        | ✅ Есть, нужно разрешать            |
| Типичное применение                                    | Основной тип индексов в БД | Специализированные случаи, кэши    |

##### Когда что использовать: практические сценарии
✅ **Используй B-tree (95% случаев):**
* Почти всегда в реляционных БД. MySQL (InnoDB), PostgreSQL, SQL Server по умолчанию создают B-tree.
* Для `WHERE`, `ORDER BY`, `JOIN`.
* Для первичных ключей (`PRIMARY KEY`), внешних ключей (`FOREIGN KEY`).
* Пример: индекс по `email`, `created_at`, `category_id`.

✅ **Используй Hash (редкие случаи)**:
* Таблица поиска (lookup table) с точными совпадениями: `WHERE product_sku = 'ABC-123'`.
* In-memory таблицы (кеш в оперативке): MySQL MEMORY engine.
* Очереди задач с поиском по ID.
* Когда нужна максимальная скорость точечного поиска и не нужны диапазоны.

##### Пример из реальной жизни
```sql
-- B-tree индекс (по умолчанию)
CREATE INDEX idx_btree ON users(created_at);

-- Hash индекс (если поддерживается)
CREATE INDEX idx_hash USING HASH ON users(api_token);

-- Запрос 1: Диапазон по дате (B-tree)
SELECT * FROM users 
WHERE created_at BETWEEN '2024-01-01' AND '2024-06-01'; 
-- Быстро: дерево проходит по отсортированным датам

-- Запрос 2: Точный поиск токена (Hash)
SELECT * FROM users 
WHERE api_token = 'a1b2c3d4e5'; 
-- Молниеносно: хэш → прямой адрес

-- Запрос 3: Сортировка (B-tree)
SELECT * FROM users ORDER BY created_at; 
-- Быстро: данные уже отсортированы в листьях дерева
```

##### Особенности в разных СУБД

| СУБД           | B-tree           | Hash                       | Комментарий                                                   |
|----------------|------------------|----------------------------|---------------------------------------------------------------|
| MySQL (InnoDB) | ✅ Основной тип   | ❌ Нет поддержки            | Adaptive Hash Index для частых точечных запросов (внутренний) |
| MySQL (Memory) | ✅ Поддерживается | ✅ Поддерживается           | Явно указывать `USING HASH` или `USING BTREE`                 |
| PostgreSQL     | ✅ Основной тип   | ✅ Есть (реже используется) | `CREATE INDEX ... USING HASH`                                 |
| SQLite         | ✅ Основной тип   | ❌ Нет встроенной поддержки |                                                               |
| Oracle         | ✅ Основной тип   | ✅ Есть                     | Hash для кластерных таблиц                                    |

##### Резюме b-tree / hash
**B-tree** — сбалансированное дерево, где данные отсортированы. Идеален для диапазонных запросов и сортировки. Это **основной тип индекса** в реляционных БД, работает за O(log n).

**Hash-индекс** — хэш-таблица, вычисляющая адрес данных через хэш-функцию. **Молниеносный поиск O(1) для точных совпадений**, но бесполезен для диапазонов и сортировки. Используется реже, в основном для lookup-таблиц или in-memory хранилищ.

На практике B-tree используется в 95% случаев, потому что обычно нужны не только точечные запросы, но и диапазоны, сортировки, JOIN'ы. Hash — специализированный инструмент, когда нужна максимальная скорость поиска по точному ключу.

В MySQL InnoDB есть **Adaptive Hash Index** — автоматическое создание хэш-индекса в памяти для «горячих» строк B-tree, что ускоряет частые точечные запросы.

#### Full-Text — полнотекстовый поиск
* Для поиска по тексту
* Поддержка морфологии, релевантности
```sql
CREATE FULLTEXT INDEX idx_content ON articles(content);
-- Поиск: WHERE MATCH(content) AGAINST('database index')
```

#### Spatial (R-Tree) — геоданные
* Для координат, полигонов
* Поиск "ближайших точек"
```sql
CREATE SPATIAL INDEX idx_location ON places(location);
-- Поиск: WHERE ST_Distance(location, POINT(10,20)) < 1000
```

### Типы индексов по функциональности
#### PRIMARY KEY (первичный ключ)
* Уникальный + **NOT NULL**
* **InnoDB**: кластеризованный индекс — данные физически хранятся в порядке PK
```sql
CREATE TABLE users (
    id INT PRIMARY KEY,  -- Автоматически создаёт индекс
    name VARCHAR(100)
);
```

#### UNIQUE INDEX (уникальный индекс)
* Гарантирует уникальность значений
* Может быть NULL (в MySQL несколько NULL — допустимы)
```sql
CREATE UNIQUE INDEX uq_email ON users(email);
-- Или при создании таблицы:
CREATE TABLE users (
    email VARCHAR(255) UNIQUE
);
```

#### INDEX (обычный, не уникальный)
* Просто для ускорения поиска
```sql
CREATE INDEX idx_created ON orders(created_at);
```

#### COMPOSITE INDEX (составной, композитный)
* Индекс по нескольким столбцам
* **Важен порядок!** Работает по принципу "левого префикса"
```sql
-- Составной индекс: (department_id, salary)
CREATE INDEX idx_dept_salary ON employees(department_id, salary);

-- ✅ Работает: WHERE department_id = 5
-- ✅ Работает: WHERE department_id = 5 AND salary > 100000
-- ❌ НЕ работает: WHERE salary > 100000 (department_id нет!)
```
**Принцип работы составных индексов (левого префикса)**
Индекс `(A, B, C)`:
* ✅ WHERE A = 1
* ✅ WHERE A = 1 AND B = 2
* ✅ WHERE A = 1 AND B = 2 AND C = 3
* ✅ WHERE A = 1 AND C = 3 (используется только A)
* ❌ WHERE B = 2 (пропущен A)
* ❌ WHERE C = 3 (пропущены A,B)

### Кластеризованные vs Некластеризованные

|            | Кластеризованный         | Некластеризованный    |
|------------|--------------------------|-----------------------|
| Количество | 1 на таблицу             | Много на таблицу      |
| Хранение   | Данные в порядке индекса | Отдельная структура   |
| Скорость   | Быстрее (данные рядом)   | Медленнее (доп. шаг)  |
| InnoDB     | PRIMARY KEY              | Все остальные индексы |
| MyISAM     | Нет кластеризованных     | Все индексы           |

### Как MySQL выбирает индекс?
```sql
-- Смотрим, какие индексы доступны
EXPLAIN SELECT * FROM users WHERE email = 'test@example.com';

-- Вывод:
-- possible_keys: idx_email, idx_name_email
-- key: idx_email           (выбранный индекс)
-- key_len: 1023            (длина используемой части)
-- rows: 1                  (сколько строк проверит)
-- type: const/ref/range    (тип доступа)
```

Типы доступа **(type в EXPLAIN)**:
* **const** — уникальный индекс, 1 строка (`WHERE id = 5`)
* **ref** — не уникальный индекс (`WHERE email = '...'`)
* **range** — диапазон (`WHERE age > 18`)
* **index** — полный scan индекса
* **ALL** — полный scan таблицы (плохо!)

### Проблемы с индексами
**Слишком много индексов:**
```sql
-- Каждый индекс замедляет INSERT/UPDATE/DELETE
-- Занимает место на диске
-- Оптимизатор может запутаться
```

**"Мёртвые" индексы:**
```sql
-- Индекс есть, но не используется
-- Проверяем через: SHOW INDEX_STATISTICS;
-- Или: SELECT * FROM sys.schema_unused_indexes;
```

**Неоптимальные индексы:**
```sql
-- Избыточные: (A,B) и (A) — второй не нужен
-- Неиспользуемые: индекс по полю, которое не в запросах
```

### В каких ситуациях индекс хорош, а когда плох?
«Индексируй только то, что читаешь часто, и не индексируй то, что часто изменяешь»

Когда индекс ХОРОШ:
- Частые поиски по конкретному полю (WHERE)
- Внешние ключи и JOIN'ы
- Сортировка и группировка (ORDER BY, GROUP BY)
- Уникальные столбцы (UNIQUE или PRIMARY KEY)
- Столбцы с высокой кардинальностью
- Составные условия поиска

Когда индекс ПЛОХ (или бесполезен):
- Поля с низкой кардинальностью (например, пол, статус, булевы)
- Часто обновляемые таблицы (Логи, INSERT, UPDATE или DELETE)
- Маленькие таблицы (<1000 строк)
- Поля, которые никогда не используются в WHERE (Очень большие текстовые поля)
- Слишком много индексов на одной таблице

### Резюме
Индексы — это отсортированные структуры для ускорения запросов. Основные типы:
1. По структуре: B-Tree (диапазоны, сортировка), Hash (точные совпадения), Full-Text (текст), Spatial (геоданные)
2. По функции: Primary (уникальный + NOT NULL), Unique (уникальность), обычные, составные

В InnoDB первичный ключ — кластеризованный индекс, данные хранятся в его порядке. Составные индексы работают по принципу левого префикса.

Индексы ускоряют SELECT, но замедляют INSERT/UPDATE/DELETE. Важно анализировать запросы через EXPLAIN и создавать индексы под конкретные запросы.

## 29) ACID, что это такое?
**ACID** — это набор свойств, которые гарантируют надежность и предсказуемость транзакций в базах данных. Это фундаментальная концепция, особенно важная для финансовых приложений, где критически важна целостность данных.
- **Atomicity** (Атомарность) (Принцип: "Все или ничего" — транзакция выполняется либо полностью, либо не выполняется вовсе.)
- **Consistency** (Согласованность) (Принцип: Транзакция переводит базу данных из одного согласованного состояния в другое.)
- **Isolation** (Изолированность) (Принцип: Параллельные транзакции не должны мешать друг другу.)
- **Durability** (Долговечность) (Принцип: Если транзакция завершена (committed), ее результаты гарантированно сохраняются, даже при сбое системы.)

## 30) Какие бывают базы данных, и чем они различаются между собой?
**Реляционные базы данных (SQL)** (MySQL, PostgreSQL, MariaDB, SQLite, MS SQL Server, Oracle.)
- Модель данных - Таблицы, связи
- Масштабирование - Вертикальное
- Сильные стороны - Транзакции, целостность

**Документно-ориентированные (NoSQL)** (MongoDB, CouchDB, Firebase Firestore)
- Модель данных - JSON/BSON/XML-документы
- Масштабирование - Горизонтальное
- Сильные стороны - Гибкость, производительность

**Ключ–значение (Key-Value Stores)** (Redis, Memcached, DynamoDB.)
- Модель данных - Key-Value пары
- Масштабирование - Горизонтальное
- Сильные стороны - Скорость, кэширование

**Графовые базы данных** (Neo4j, OrientDB, ArangoDB.)
- Модель данных - Узлы и связи
- Масштабирование - Горизонтальное
- Сильные стороны - Поиск связей, рекомендации

**Колонночные базы данных** (ClickHouse, Cassandra, HBase.)
- Модель данных - Колонки
- Масштабирование - Горизонтальное
- Сильные стороны - Аналитика, агрегации, большие объемы данных (BigData)

**Поисковые движки** (Elasticsearch, OpenSearch)
- Модель данных - Документы + индекс
- Масштабирование - Горизонтальное
- Сильные стороны - Полнотекстовый поиск

**Временные (Time Series) базы данных** (InfluxDB, TimescaleDB, Prometheus.)

## 31) Clickhouse, какая БД? Реляционная или нет?
**ClickHouse** — не реляционная БД, а колоночная аналитическая система (OLAP-систем — Online Analytical Processing)
- SQL-совместимая (но с ограничениями)
- НЕ реляционная в классическом понимании
- НЕ для OLTP-нагрузок (Online Transaction Processing)
- Быстрые агрегатные функции по колонкам, БД работает на чтение > запись

## 32) В каком виде хранятся данные в PostgreSQL?
Данные в PostgreSQL хранятся в виде строк (Rows), организованных в таблицы (Tables), что соответствует реляционной модели. Однако на физическом уровне (на диске) данные хранятся в виде файлов, состоящих из страниц (Pages).

## 33) Что такое Redis, где используется?
**Redis** — это (in-memory) база данных типа "ключ-значение" с открытым исходным кодом. Название расшифровывается как REmote DIctionary Server.

**Хорошие сценарии**:
- Кэширование (сессии, HTML, данные)
- Очереди (отложенные задачи)
- Счетчики (просмотры, лайки)
- Временные данные (корзины, коды подтверждения)
- Реальное время (чаты, уведомления)

**Плохие сценарии**:
- Большие бинарные данные (файлы, изображения)
- Сложные запросы (нет JOIN, WHERE)
- Данные > доступной RAM (вытеснение старых данных)
- Критически важные данные (риск потери при перезагрузке)

## 34) Какие подтипы нереляционных БД существуют?
Документные БД (Document Stores) 
- Хранение документов в формате JSON/BSON/XML 
- MongoDB/Couchbase

Ключ-Значение (Key-Value Stores) 
- Простой словарь ключ → значение
- Redis/Memcached

Колоночные БД (Column-Family Stores) 
- Данные хранятся по колонкам, а не по строкам 
- ClickHouse/Cassandra

Графовые БД (Graph Databases) 
- Узлы (nodes-сущности) и ребра (edges-связи) 
- Neo4j

Поисковые движки (Search Engines)
- Специализированные БД для полнотекстового поиска
- Elasticsearch/OpenSearch

БД временных рядов (Time-Series Databases)
- Оптимизированы для данных с метками времени
- InfluxDB

## 35) Что такое Explain, в контексте БД?
**EXPLAIN** — это команда в SQL-базах данных, которая показывает план выполнения запроса.
- Оптимизация медленных запросов
- Понимание как работает БД (использует ли запрос индексы, и какие)
- Выявление узких мест
- Проверка использования индексов

## 36) Как используется принцип SRP (SOLID) в Laravel?
Laravel сам реализует SRP во многих местах:
- Form Requests — только валидация.
- Middleware — только фильтрация и проверка запросов.
- Jobs / Listeners — выполняют одну задачу (например, отправку письма).
- Mailables — отвечают только за формирование письма.
- Policies / Gates — отвечают за авторизацию.

## 37) В какой класс лучше вывести проверку данных (валидацию) с контроллера в Laravel?
Для большинства случаев — Form Request.

Альтернативы:
- Service Classes
- Custom Validator
- Traits
- Rules Objects

## 38) Какой принцип SOLID будет использован при разделении данного контроллера?
Основной принцип: SRP (Single Responsibility Principle).

Дополнительно применяются:
- DIP через dependency injection
- OCP через возможность расширения
- LSP через заменяемость сервисов
- ISP через разделенные интерфейсы

## 39) Расскажи про жизненный цикл запроса в Laravel?
**1. Вход в приложение (public/index.php):**
- Загружает автозагрузчик Composer'а
- Создаёт и запускает ядро приложения (App\Http\Kernel)

**2. Создание экземпляра приложения (app.php):**
- Файл bootstrap/app.php создаёт основу фреймворка — контейнер зависимостей (Service Container).

**3. Обработка через HTTP Kernel**

**4. Middleware Pipeline (Запрос проходит через стек middleware):**
  - Глобальные Middleware (Request → TrustProxies → CheckForMaintenanceMode → ValidatePostSize →)
  - Группы Middleware (например, 'web') (→ EncryptCookies → VerifyCsrfToken → ...)

**5. Маршрутизация: Router (Router находит подходящий маршрут)**

**6. Контроллер и обработка**
  - Получает данные от пользователя;
  - Может вызвать модель, сервис, валидацию (FormRequest);

**7. Модели и Eloquent ORM**

**8. Service Providers Загрузка**

**9. Возврат Response:**
  - return response()->json($data);
  - return view('template');
  - return redirect('/home');
  - Middleware обрабатывают response на обратном пути (← AddHeaders ← EncryptCookies ← ...)

**10. Завершение: Termination и HTTP Response клиенту**

## 40) В 10 версии Laravel существовал therm файл за что он отвечал?
- Временный маркер для отслеживания состояния приложения
- Инструмент для "hot reload" в режиме разработки
- Автоматически управляется фреймворком
- Не предназначен для ручного редактирования
- Не должен попадать в репозиторий

## 41) Что такое middleware в Laravel, и какой функционал он выполняет?
**Middleware** (Промежуточное ПО) в Laravel — это механизм, который действует как фильтр, обрабатывая HTTP-запросы, прежде чем они достигнут контроллера, и HTTP-ответы, прежде чем они будут отправлены клиенту.

**Схема** (HTTP Request → Global Middleware → Route Middleware → Controller → Route Middleware → Global Middleware → HTTP Response)

**Использование** (Аутентификация, Защита CSRF, Кэширование, Throttling, CORS, Обслуживание, Локализация, Логирование)

## 42) Что такое события в Laravel, как и где используются?
**События (Events)** в Laravel — это простой и мощный механизм паттерна **Наблюдатель (Observer Pattern)**. Они позволяют регистрировать определённые действия или происшествия в приложении и прикреплять к ним обработчики (Listeners).
- События (Events) — это способ сообщить системе, что что-то произошло.
- Слушатели (Listeners) — это куски кода, которые реагируют на это событие.

**Когда использовать события?**
- Отправка уведомлений
- Обновление связанных данных
- Логирование активности
- Кэширование и инвалидация
- Интеграция с внешними сервисами

## 43) Что такое обсерверы?
**Обсерверы (Observers)** в Laravel — это специальные классы, которые позволяют "наблюдать" за событиями модели Eloquent и реагировать на них. (creating, created, updating, updated, deleting, deleted, restoring, restored)

**Когда использовать обсерверы:**
- Генерация slug
- Удаление файлов при удалении модели
- Логирование изменений
- Отправка уведомлений при создании

## 44) Как в Laravel можно ограничить количество подключений одного пользователя к ip адресу приложения?
Throttle Middleware (Встроенная защита)

Rate Limiting с аутентификацией

Кастомный Rate Limiter

## 45) Как в Laravel реализовываются запросы на сторонние приложения, что для этого применяются?
Фасад HTTP Client Laravel (Guzzle под капотом)

## 46) Что такое Guzzle в чем его удобство, и какую функцию он реализует в PHP?
**Guzzle** — это PHP HTTP-клиент, который упрощает отправку HTTP-запросов и интеграцию с веб-сервисами. Это библиотека, на которой построен HTTP-клиент Laravel.
- Назначение	Выполнение HTTP-запросов
- Реализует	Клиент для REST, SOAP, JSON API и т.д.
- Под капотом	cURL
- Используется в	Laravel (Http), Symfony, WordPress, SDK от AWS и др.
- Уровень	Must-have для любого backend-разработчика

## 47) Можно ли по нему авторизовываться?
Guzzle отлично подходит для авторизации и поддерживает:
- Bearer Tokens (JWT, OAuth)
- OAuth 1.0/2.0 все flow
- Basic/Digest Auth
- API Keys (headers, query params)
- Cookie-based аутентификация
- Кастомные схемы аутентификации

## 48) Какая структура HTTP запроса?
**Start Line (Первая строка)** (GET /api/users HTTP/1.1):
- Метод - GET, POST, PUT, DELETE и т.д.
- URI - путь к ресурсу (/api/users)
- Версия HTTP - HTTP/1.1 или HTTP/2

**Headers (Заголовки)**
- Общие заголовки (Connection, Cache-Control)
- Заголовки запроса (Host, User-Agent, Accept, Accept-Language, Accept-Encoding, Authorization)
- Заголовки содержимого (Content-Type, Content-Length, Content-Encoding)

**Empty Line (Пустая строка)** (разделитель между заголовками и телом)

**Body (Тело запроса)** - опционально

**ПРИМЕР POST запрос с JSON телом:**
```
POST /api/users HTTP/1.1
Host: api.example.com
Content-Type: application/json
Content-Length: 87
Authorization: Bearer token123
User-Agent: MyApp/1.0

{
"name": "Alice Smith",
"email": "alice@example.com",
"password": "securepassword123"
}
```
## 49) В каком элементе запроса хранятся данные по авторизации?
**Authorization Header** (Самый распространенный):
- Bearer Token (JWT, OAuth) (Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...)
- Basic Auth (Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=) - login:password в base64
- Digest Auth (Authorization: Digest username="user", realm="example", nonce="abc123")
- API Key (иногда) (Authorization: APIKey your-api-key-here)

**Custom Headers** (Кастомные заголовки) (X-API-Key, X-API-Token, X-Auth-Token, API-Key)

**Cookies (Для сессий**) (Cookie: session_id=abc123def456; auth_token=xyz789;)

**Query Parameters (В URL)** (GET /api/data?api_key=your_key_123&token=abc123)

**Body Data** (Form-based аутентификация)

## 50) Что такое Bearer?
**Bearer (от англ. "носитель")** — это тип аутентификации, где наличие токена дает право доступа к защищенным ресурсам. Тот, кто "несет" (has bearer) токен, получает доступ.

**Authorization: Bearer <token>**
- Схема аутентификации для передачи токенов
- Простой стандарт - Authorization: Bearer <token>
- Универсальный - работает с JWT, OAuth, кастомными токенами
- Без состояния (stateless) - серверу не нужно хранить сессию
- Стандарт де-факто для REST API и мобильных приложений

## 51) Что такое Eloquent ORM, для чего используется, какие типы связи есть?
**Eloquent ORM (Object-Relational Mapping)** — это реализация паттерна Active Record в Laravel, который позволяет работать с базой данных используя объектно-ориентированный синтаксис вместо SQL запросов.

**Для чего используется Eloquent?**
- Упрощение работы с БД
- Объектно-ориентированный подход
- Безопасность от SQL-инъекций

**Типы связей в Eloquent:**
- One To One (Один к одному) (User hasOne Profile, Profile belongsTo User)
- One To Many (Один ко многим) (User hasMany Post, Post belongsTo User)
- Many To Many (Многие ко многим) (Post belongsToMany Tag, Tag belongsToMany Post) PIVOT table post_tag
- Has Many Through (Имеет много через) (Country hasManyThrough Post, User)
- Polymorphic Relations (Полиморфные связи) (Comment morphTo, Post morphMany Comment, Video morphMany Comment)
- Many To Many Polymorphic (Полиморфные многие ко многим) (Tag morphedByMany Post, Tag morphedByMany Video, Post morphToMany Tag, Video  morphToMany Tag)

## 52) Что такое SQL инъекции?
**SQL инъекция** — это атака, при которой злоумышленник внедряет вредоносный SQL-код в запросы к базе данных, чтобы получить несанкционированный доступ к данным или выполнить несанкционированные операции.

`(' OR '1'='1' --)`

**Защита от SQL инъекций:**
- Подготовленные выражения (Prepared Statements)
- Экранирование данных

## 53) ORM защищает от SQL инъекций? Или все равно можно получить несанкционированый доступ?
**ЗАЩИЩЕНО автоматически:**
- Все методы Eloquent (where(), find(), create() etc.)
- Query Builder с биндингом параметров
- PDO prepared statements

**ТРЕБУЕТ осторожности:**
- DB::raw(), whereRaw(), selectRaw()
- DB::statement()
- Динамические имена таблиц/колонок (Нужно делать белые списки для ORDER BY)

**НЕ ЗАЩИЩАЕТ от:**
- Logic flaws (логические ошибки приложения)
- Mass assignment (если не настроены $fillable/$guarded)
- NoSQL injection (для нереляционных БД)
- XSS, CSRF, etc. (другие типы атак)

## 54) Что такое Job в Laravel, для чего они нужны, как они работают, кто их запускает?
**Job** — это класс, который представляет собой задачу, которая может быть выполнена в фоновом режиме, отдельно от основного HTTP-запроса.

**Для чего нужны Jobs?**
- Долгие операции (обработка видео)
- Отправка email
- Обработка данных (Генерация отчетов, Синхронизация с внешними API, Обработка изображений)

**Как работают Jobs?**
- Диспатч: ProcessPayment::dispatch($user, 100)
- Сериализация: Job преобразуется в JSON и сохраняется в очередь
- Хранение: Данные хранятся в Redis/Database/SQS
- Обработка: Worker забирает задачу из очереди
- Выполнение: Вызывается метод handle()
- Завершение: Job удаляется из очереди

**Кто запускает Jobs?**

Jobs не запускаются самим PHP-скриптом, который обрабатывает HTTP-запрос. Их запускают Worker-процессы (рабочие процессы).
- Worker (Рабочий процесс): Это процесс, запущенный в фоновом режиме на сервере, который постоянно слушает очередь.
- Команда Artisan: Worker запускается с помощью команды Artisan Queue Worker (php artisan queue:work)
- Менеджеры процессов: На продакшене queue:work запускается и управляется специальными менеджерами процессов (например, Supervisor), которые гарантируют, что Worker всегда активен, перезапускается при сбоях и запускается при старте сервера.

## 55) Какой инструмент в Laravel управляет этими очередями?
**Разработка**: queue:listen или queue:work

**Продакшен**: Horizon (Redis) + Supervisor (Unix)

**Администрирование**: Artisan commands (queue:failed, queue:retry)

## 56) Что такое Supervisor?
**Supervisor** — это системный демон для Unix-систем, который управляет процессами и гарантирует их постоянную работу.
- Запускает процессы и следит за их работой
- Автоматически перезапускает упавшие процессы
- Управляет несколькими процессами одновременно
- Предоставляет веб-интерфейс для мониторинга

## 57) Сколько Worker можно запустить на 1 задачу? Для чего это делается?
На одну задачу (Job) → 1 Worker

Но на тип задач можно запустить много Workers для:
- Параллелизм - 8 workers вместо 1 (В 8 раз быстрее обработка)
- Пиковые нагрузки - 50 workers на Black Friday (Без задержек для пользователей)
- Приоритизация - 10 workers для платежей, 2 для email (Важные задачи обрабатываются первыми)
- Балансировка - Разные workers для CPU/I/O задач (Оптимальное использование ресурсов)

## 58) Где хранятся настройки Laravel?
Файлы конфигурации (config/)

Файлы переменных окружения (.env)

Файлы окружения по environment (опционально) (.env.local, .env.staging, .env.production)

## 59) Какие минусы могут возникнуть при использовании обсервера в контроллере? Например в Post при привязке тегов?
- Нарушение Single Responsibility Principle (SRP)
- Сложность тестирования
- Неявные побочные эффекты
- Проблемы с транзакциями
- Сложность отладки

Правильная альтернатива: Service (Action) Class

## 60) Если после изменения роутинга, перестал работать проект, какие команды рекомендуется использовать в Laravel?
Приоритетная последовательность:
1. `php artisan route:clear`          - Самое важное!
2. `php artisan route:list`           - Проверить роуты
3. `composer dump-autoload`          - Перезагрузить классы
4. `php artisan cache:clear`         - Очистить кэш данных
5. `php artisan config:clear`        - Очистить кэш конфигов
   
Если не помогло:
6. `php artisan optimize:clear`      - Полная очистка
7. `php artisan package:discover`    - Пере discover пакетов
8. `php artisan route:cache`         - Кэшировать заново

## 61) Вопрос по гиту, предположим начинаем свою ветку переносить в мастер, и появился конфликт, какие наши первые действия?
- `git status` — посмотреть что случилось
- `git diff` — проанализировать конфликты
- Редактировать файлы — убрать `<<<<<<<, =======, >>>>>>>`
- `git add .` — добавить исправленные файлы
- `git commit` — завершить слияние
- `git push` — отправить изменения

## 62) Что такое чери пик?
**Cherry-pick** — это операция "выборочного копирования" конкретных коммитов между ветками.

**Когда использовать cherry-pick:**
- Срочные фиксы из development в production
- Backport исправлений между версиями
- Восстановление потерянных коммитов
- Частичный перенос фич

**Когда НЕ использовать cherry-pick:**
- Для регулярного кода между ветками
- Когда можно использовать merge/rebase
- Для больших feature-веток

## 63) Чем отличается git merge от git rebase?
`git merge` объединяет ветки, создавая новый merge-коммит и сохраняя историю ветвления.

`git rebase` переписывает историю, «перенося» коммиты одной ветки поверх другой,
делая историю линейной.

В рабочих ветках часто используют `rebase` для чистой истории,
а в общих ветках — `merge`, чтобы избежать конфликтов истории.

## 64) Как работает команда git reset?
`git reset` перемещает указатель ветки (HEAD) на другой коммит и опционально обновляет рабочую директорию и индекс.
1. `--soft` — Только перемещает HEAD
2. `--mixed` (по умолчанию) — + Обновляет индекс
3. `--hard` — + Обновляет рабочую директорию

## 65) Что такое моковое тестирование, и область его применения?
**Моковое тестирование (Mock Testing)** - это техника тестирования, где мы создаем "подставные" объекты вместо реальных зависимостей.
```php
// Пример на PHPUnit
public function testOrderProcessing() {
    // 1. Создаем "куклу" банка
    $mockBank = $this->createMock(BankGateway::class);

    // 2. Настраиваем её: "Если вызовут charge, верни true"
    $mockBank->method('charge')->willReturn(true);

    // 3. Передаем куклу в наш сервис вместо настоящего банка
    $service = new OrderService($mockBank);

    // 4. Проверяем, что сервис работает
    $this->assertTrue($service->processOrder(100));
}
```
### Области применения:
1. **Внешние сервисы** (платежи, почта, API)
2. **Базы данных** - чтобы не зависеть от реальных данных
3. **Сложные вычисления** - когда нужно тестировать логику, а не производительность
4. **Еще не реализованный функционал** - можно тестировать свою часть кода, пока коллеги делают смежные модули

### Когда НЕ использовать моки:
1. Тестирование конечного пользовательского сценария
2. Проверка интеграции с реальными сервисами
3. Когда проще использовать реальный объект

## 65) Какая проблема может возникнуть с моками при тестировании интерфейсов?
Главная проблема моков при тестировании интерфейсов называется **«Рассинхрон» (Drift)** или **«Ложно-позитивные тесты»**.

### Как это лечится?
**Интеграционные тесты.** Хотя бы один тест должен проверять работу с реальным классом (или базой/сервисом), чтобы убедиться, что все части системы всё еще понимают друг друга правильно.

## 66) Паттерны проектирования, на какие категории делятся, и какие и где активно используются?
**Паттерны проектирования** — это типовые решения частых проблем в проектировании ПО. Они делятся на **3** основные категории:

### Порождающие (Creational) - создание объектов
**Суть:** Решают проблему «Как создать объект, не используя везде `new ClassName()`».
**Зачем:** Чтобы код не зависел от конкретных классов.

#### Singleton (Одиночка)
**Суть**: Класс, у которого может быть только **ОДИН** экземпляр на всё приложение. Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа. Но считается анти-паттерном, так как создает скрытые зависимости и сложно тестируется
```php
// В Laravel - сервис-контейнер часто возвращает singleton'ы
$logger = app(Logger::class); // Всегда один экземпляр
```

#### Factory Method (Фабричный метод)
**Суть**: Есть интерфейс для создания объекта, но какой именно класс создать — решают наследники.
```php
// В Laravel - фабрики моделей
User::factory()->create();
```

#### Builder (Строитель)
**Суть**: Позволяет создавать сложные объекты пошагово.
```php
// SQL Query Builder в Laravel!
DB::table('users')->where('id', 1)->orderBy('name')->get();
```

#### Abstract Factory - создает семейства связанных объектов

#### Prototype - клонирование существующих объектов

### Структурные (Structural) - композиция объектов
**Суть**: Решают проблему «Как собрать классы и объекты в более крупные структуры».
**Зачем**: Чтобы старое работало с новым и не ломалось.

### Adapter (Адаптер)
**Суть**: «**Переходник**». Позволяет объектам с несовместимыми интерфейсами работать вместе.
```php
// В Laravel - адаптеры для файловых систем
Storage::disk('s3')->put('file.jpg', $contents);
```

#### Facade (Фасад)
**Суть**: Простой интерфейс к сложной системе классов.
```php
// Фасады Laravel
Cache::get('key');
DB::table('users')->get();
```

#### Decorator (Декоратор/Обертка)
**Суть**: Динамически добавляет объекту новые обязанности (оборачивает его), не меняя сам класс.
```php
// Middleware в Laravel - классический декоратор
Route::middleware(['auth', 'admin'])->get(...);
```

#### Composite - древовидные структуры объектов

#### Proxy - контроль доступа к объекту

### Поведенческие (Behavioral)
**Суть**: Решают проблему «Как объекты общаются друг с другом и распределяют обязанности».

#### Observer (Наблюдатель)
**Суть**: Один объект меняется, все подписчики узнают об этом автоматически.
```php
// События в Laravel
UserCreated::dispatch($user);
```

#### Strategy (Стратегия)
**Суть**: Мы выносим набор алгоритмов в отдельные классы и делаем их взаимозаменяемыми.
**Пример**: Оплата.
У тебя есть интерфейс `PaymentInterface` с методом `pay()`.
Есть стратегии: `PayPalStrategy`, `StripeStrategy`, `CashStrategy`
```php
// Разные стратегии кэширования в Laravel
config('cache.default'); // redis, file, database
```

#### Iterator (Итератор)
**Суть**: Способ последовательно обходить элементы сложного объекта (коллекции).

#### Command - инкапсуляция запросов как объектов
```php
// Artisan команды
php artisan make:controller TestController
```

## 67) Движки БД MYSQL, какие есть, в чем отличие, на что нужно обращать внимание
**Движки БД (Storage Engines)** - это компоненты СУБД, отвечающие за хранение, обработку и извлечение данных. 

В мире MySQL (самой популярной БД для PHP) движок (Storage Engine) — это модуль, который отвечает за то, как именно данные хранятся на диске, как они читаются и обновляются.

### MyISAM (устаревший, но встречается)
Раньше был дефолтным (до версии 5.5). Сейчас считается устаревшим.
* **Главная фишка**: Очень быстрый на ЧТЕНИЕ.
* **Главный минус**: Блокировка всей таблицы (Table-level locking).
* **Нет транзакций**: Если во время записи выключат свет — данные могут побиться.
* **Нет внешних ключей (Foreign Keys)**: База не следит за тем, чтобы у Заказа обязательно был существующий Пользователь.
* **FULLTEXT-индексы**

### InnoDB (стандарт с MySQL 5.5+)
Используется по умолчанию во всех современных проектах
* **Главная фишка**: Транзакции (ACID).
* **Блокировка строк** (Row-level locking).
* **Надежность**: Умеет восстанавливаться после сбоев.
* **Внешние ключи**: Гарантирует целостность связей.
* Кэширование данных и индексов

## 68) Блокировки в БД, оптимистичные и пессимистичные, что это и что нужно знать?
**Блокировки в БД** - это механизмы контроля доступа к данным при параллельных операциях.

### Пессимистичные блокировки (Pessimistic Locking)
**Философия**: "Лучше перебдеть" - предполагаем, что конфликты будут часто, поэтому блокируем данные заранее.
```sql
-- Явная блокировка строки на время транзакции
BEGIN;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
-- Другие транзакции ждут, пока мы не сделаем COMMIT/ROLLBACK
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;
```
```php
DB::transaction(function () {
    $account = Account::where('id', 1)->lockForUpdate()->first();
    $account->balance -= 100;
    $account->save();
});
```
**Где использовать:**
* Банковские транзакции
* Бронирование мест
* Системы с высокой конкуренцией за данные

**Проблемы:**
* Могут возникать взаимоблокировки (deadlocks)
* Снижают производительность при высокой нагрузке

### Оптимистичные блокировки (Optimistic Locking)
**Философия**: "Конфликты редки" - разрешаем всем читать данные, но проверяем при записи, не изменились ли они.
```sql
ALTER TABLE products ADD COLUMN version INT DEFAULT 0;
```
```php
// В коде проверяем версию
$product = Product::find(1);
$product->name = 'New Name';
$product->price = 99.99;

// Проверяем, что никто не изменил запись пока мы работали
$affected = Product::where('id', 1)
              ->where('version', $product->version)
              ->update([
                  'name' => $product->name,
                  'price' => $product->price,
                  'version' => $product->version + 1
              ]);

if ($affected === 0) {
    throw new OptimisticLockException('Данные были изменены другим пользователем');
}
```
**Где использовать:** Редактирование профиля, админка, комментарии. Там, где столкновения редки.

**Проблемы:** Если конфликт случился, пользователю вылетит ошибка, и ему придется вводить данные заново (или нам надо писать код для повторной попытки).

## 69) Что такое Deadlock и как его избежать?
**Deadlock (Взаимоблокировка)** - это ситуация, когда две или более транзакций блокируют друг друга, каждая ожидает ресурс, занятый другой.

### Способы избежать deadlock:
#### Единый порядок блокировки
Всегда блокируйте ресурсы в одинаковом порядке:
```php
// Всегда блокируем по возрастанию ID
DB::transaction(function () {
    $accounts = Account::whereIn('id', [1, 2])
                 ->orderBy('id')
                 ->lockForUpdate()
                 ->get();
});
```
#### Короткие транзакции
```php
// ❌ Долгая транзакция = выше риск deadlock
DB::transaction(function () {
    $account = Account::lockForUpdate()->find(1);
    // ... сложная бизнес-логика ...
    // ... вызовы внешних API ...
    $account->save();
});

// ✅ Короткая транзакция
$account = Account::find(1);
// ... вся логика ВНЕ транзакции ...
DB::transaction(function () use ($account) {
    $account->lockForUpdate()->save();
});
```
#### Использование таймаутов/retry
```php
// В config/database.php
'mysql' => [
    'options' => [
        PDO::ATTR_TIMEOUT => 10,
    ]
];

// Или на уровне транзакции
DB::transaction(function () {
    // ...
}, 3); // Количество попыток при deadlock
```
#### Избегание ненужных блокировок
```php
// ❌ Лишняя блокировка
$user = User::lockForUpdate()->find(1); // Зачем блокировка для чтения?

// ✅ Чтение без блокировки  
$user = User::find(1);

// ✅ Блокировка только при реальной необходимости
DB::transaction(function () {
    $user = User::lockForUpdate()->find(1);
    $user->balance += 100;
    $user->save();
});
```
#### Использование пессимистичных блокировок с умом
```php
// Вместо lockForUpdate() на всю таблицу
DB::transaction(function () {
    // Блокируем только нужные строки
    $accounts = Account::whereIn('id', [1, 2])
                 ->lockForUpdate()
                 ->get();
});
```

## 70) Уровни изоляции БД
**Уровни изоляции БД** - это настройки, определяющие, насколько транзакции "видят" изменения друг друга. Чем строже уровень, тем больше согласованность данных, но ниже производительность.

### 4 стандартных уровня изоляции (от слабого к строгому):
#### 1 - Read Uncommitted (Чтение незафиксированных данных)
**Что позволяет:** Читать данные, которые другие транзакции еще не закоммитили.
**Проблемы:** Грязное чтение (Dirty Read) - видите "грязные" данные, которые могут быть откатаны
```sql
-- Транзакция 1
BEGIN;
UPDATE users SET balance = 1000 WHERE id = 1; -- Не коммитил

-- Транзакция 2 (Read Uncommitted)
SELECT balance FROM users WHERE id = 1; -- Увидит 1000!
-- Если транзакция 1 сделает ROLLBACK - данные недействительны
```

#### 2 - Read Committed (Чтение зафиксированных данных)
**Что позволяет:** Видеть только закоммиченные данные.
**Проблемы:** Неповторяемое чтение (Non-repeatable Read) - данные меняются между чтениями
```sql
-- Транзакция 1
BEGIN;
SELECT balance FROM users WHERE id = 1; -- Вернуло 100

-- Транзакция 2
UPDATE users SET balance = 200 WHERE id = 1;
COMMIT;

-- Транзакция 1
SELECT balance FROM users WHERE id = 1; -- Теперь 200! Данные изменились
```

#### 3 - Repeatable Read (Повторяемое чтение)
**Что позволяет:** Гарантирует, что данные не меняются в рамках одной транзакции.
**Проблемы:** Фантомное чтение (Phantom Read) - появляются новые строки
```sql
-- Транзакция 1
BEGIN;
SELECT COUNT(*) FROM users WHERE age > 30; -- Вернуло 5

-- Транзакция 2  
INSERT INTO users (name, age) VALUES ('John', 35);
COMMIT;

-- Транзакция 1
SELECT COUNT(*) FROM users WHERE age > 30; -- Теперь 6! Появилась новая строка
```

#### 4 - Serializable (Сериализуемый)
**Что позволяет:** Полная изоляция - транзакции выполняются последовательно.
**Преимущества:** Нет аномалий
**Недостатки:** Низкая производительность

### Уровни изоляции в разных СУБД:
MySQL (InnoDB): По умолчанию: REPEATABLE READ
PostgreSQL: По умолчанию: READ COMMITTED

### Как выбрать уровень изоляции:
1. **Read Uncommitted**	Аналитика, отчеты (где не важна точность)	🟢🟢🟢
2. **Read Committed**	Большинство веб-приложений 🟢🟢🟡
3. **Repeatable Read**	Финансовые операции, бронирования 🟢🟡🔴
4. **Serializable**	Критически важные операции 🔴🔴🔴

## 71) Оператор DISTINCT в SQL - что это и зачем применять?
**Оператор DISTINCT** - это ключевое слово в SQL, которое убирает дублирующиеся строки из результата запроса.

### Синтаксис и варианты использования:
```sql
-- Уникальные категории товаров
SELECT DISTINCT category FROM products;

-- Уникальные комбинации категория+поставщик
SELECT DISTINCT category, supplier FROM products;

-- Количество уникальных категорий
SELECT COUNT(DISTINCT category) FROM products;
```

### Важные особенности DISTINCT:
#### Производительность
```sql
-- DISTINCT требует сортировки и сравнения данных
-- На больших таблицах может быть медленным
SELECT DISTINCT name FROM users; -- Медленно на 1M записей

-- Альтернатива - использовать GROUP BY
SELECT name FROM users GROUP BY name; -- Иногда быстрее
```

#### Работа с NULL значениями
```sql
-- DISTINCT считает все NULL одинаковыми
SELECT DISTINCT email FROM users;
-- Все NULL значения будут свернуты в одну строку
```

#### С агрегатными функциями
```sql
-- Правильно: DISTINCT внутри COUNT
SELECT COUNT(DISTINCT category) FROM products; -- 3

-- Неправильно: DISTINCT снаружи
SELECT DISTINCT COUNT(category) FROM products; -- Не то, что ожидалось
```

### Когда использовать DISTINCT:

✅ **Подходящие случаи:**
* Получение уникальных значений для выпадающих списков
* Аналитика и отчеты (уникальные пользователи, категории)
* Поиск дубликатов данных

❌ **Когда НЕ использовать:**
* Вместо правильной нормализации БД
* На очень больших таблицах без индексов
* Когда нужны все данные (например, для пагинации)

# Отдельный раздел, который нужно будет объединить с основным и разбить на подразделы
## Какой основной протокол интернета?
Семейство протоколов **TCP/IP** (Transmission Control Protocol / Internet Protocol). Это Транспортный и Сетевой уровни (Layer 4 и 3).

**HTTP** — это Прикладной уровень (Layer 7 по модели OSI). Это язык, на котором браузер говорит с сервером. Для веба.

## Какие есть версии HTTP протокола? Какие их отличия?
**HTTP/1.1** — классический, текстовый, последовательные запросы, существует keep-alive, но всё равно head-of-line blocking.

**HTTP/2** — бинарный, мультиплексирование в одном соединении, сжатие заголовков, быстрее под нагрузкой.

**HTTP/3** — работает поверх QUIC/UDP, лучше справляется с потерями пакетов, самый быстрый, уже активно внедряется.

### Ключевые отличия между версиями HTTP:
#### HTTP/1.1 vs HTTP/2:
* **Бинарный протокол:** HTTP/2 использует бинарные фреймы вместо текста, что ускоряет парсинг
* **Мультиплексирование:** Одно TCP-соединение для параллельных запросов (решает проблему head-of-line blocking)
* **Сжатие заголовков:** HPACK уменьшает избыточность заголовков
* **Server Push:** Сервер может отправлять ресурсы до запроса клиента
* **Приоритизация:** Клиент может указать приоритеты запросов

#### HTTP/2 vs HTTP/3:
* **Транспортный протокол:** HTTP/3 использует QUIC поверх UDP вместо TCP
* **Улучшенное мультиплексирование:** Решает проблему head-of-line blocking на транспортном уровне
* **Быстрое установление соединения:** 0-RTT handshake в некоторых сценариях

### Какой протокол под HTTP?
#### Классика (HTTP/1.1 и HTTP/2):
Работают поверх **TCP** (Transmission Control Protocol).

**Почему**: TCP гарантирует, что данные дойдут **целыми и в правильном порядке**. Если пакетик потерялся по дороге, TCP его перешлет. Для веба это критично (мы не хотим видеть пол-картинки).

#### Новая школа (HTTP/3):
Работает поверх **UDP** (User Datagram Protocol) через прослойку QUIC.

**Почему**: TCP слишком «тяжелый» и медленный на старте (долгое рукопожатие). UDP — это «выстрелил и забыл», он супер-быстрый. Google придумал протокол QUIC, который берет быстрый UDP и добавляет ему надежность (как у TCP), но без тормозов.

## Директива DECLARE в контексте PHP, что это и зачем?
`declare` — это конструкция, которая управляет поведением PHP-интерпретатора на уровне файла или блока.

### declare(strict_types=1)
Чаще всего используется `declare(strict_types=1)`, чтобы включить строгую типизацию для входных параметров и возвращаемых значений.

Заставляет PHP не преобразовывать типы автоматически. Если функция ждет int, а ты передал строку "5", PHP выбросит ошибку TypeError (вместо того чтобы молча превратить строку в число).

Ещё есть режимы типа `ticks` и `encoding`, но они используются редко.

### declare(ticks=1);
**Зачем**: Говорит PHP: "Каждую 1 операцию (или N операций) проверяй, не пришел ли сигнал от системы".

**Где применяется**: При работе с **асинхронными сигналами** (PCNTL). Например, чтобы скрипт можно было корректно остановить командой kill или Ctrl+C в консоли, или для обработки очередей (RabbitMQ воркеров).

### declare(encoding='...');
Используется для указания кодировки скрипта. Сейчас почти не нужно, так как везде UTF-8.

### Область действия DECLARE в PHP:
**Файловая область видимости:**
```php
// Действует ТОЛЬКО на текущий файл
declare(strict_types=1);

// Если подключаются другие файлы - на них НЕ распространяется
require 'other_file.php';
```

**Блочная область видимости:**
```php
// Действует ТОЛЬКО на блок кода в фигурных скобках
declare(strict_types=1) {
    $a = function(int $x): int { return $x; };
    // Здесь strict_types=1
}
// Здесь уже НЕ действует strict_types=1
```

**Не распространяется на:**
* Подключаемые файлы (include/require)
* Функции и классы из других файлов
* Вызовы извне файла

## Директивы REQUIRE/INCLUDE
`require` и `include` оба подключают внешний файл и исполняют его код.

### Основные различия:
1. **При отсутствии файла:**
* `require` - фатальная ошибка **(E_COMPILE_ERROR)**, выполнение останавливается
* `include` - предупреждение **(E_WARNING)**, выполнение продолжается

2. **Практическое применение:**
* `require` - для обязательных файлов (настройки, основные классы)* 
* `include` - для опциональных блоков (шаблоны, виджеты)

3. **Вариации:**
* `require_once`/`include_once` - гарантируют однократное подключение файла, чтобы избежать переопределения классов или функций

## Файлы Composer - composer.json/composer.lock
**Composer использует два файла:**
— `composer.json` описывает требования — какие пакеты и в каких диапазонах версий нужны проекту. (например, ^8.0).
— `composer.lock` фиксирует точные версии всех установленных библиотек и их зависимостей. (например 8.1.2)

Это нужно для того, чтобы любой разработчик и любой сервер получили идентичную версию окружения. Без lock-файла Composer мог бы подтянуть более свежие версии, что приводит к разному поведению на проде и у разработчиков. 

`composer.lock` Создается автоматически при `composer install` или `composer update`

## Позднее статическое связывание (Late Static Binding)
**Позднее статическое связывание** — это механизм, который позволяет статическим вызовам в наследуемых классах использовать тот класс, из которого выполняется вызов. В PHP это реализовано через ключевое слово `static`.

В отличие от `self`, который всегда ссылается на класс, где метод объявлен, `static` использует реальный класс вызова.

Это важно для корректной работы наследования, особенно в шаблонных методах, фабриках и статических конструкторах.

**Ключевые моменты:**
`self` - привязка на этапе компиляции (к классу где написан)
`static` - привязка на этапе выполнения (к классу откуда вызван)

```php
class Car
{
    public static function model()
    {
        return 'Просто машина';
    }

    public static function getEarly()
    {
        // SELF: Смотрит на класс, где написана эта строчка
        return self::model();
    }

    public static function getLate()
    {
        // STATIC: Смотрит на класс, который реально вызвал метод
        return static::model();
    }
}

class BMW extends Car
{
    public static function model()
    {
        return 'X5';
    }
}

// ВЫЗЫВАЕМ:
echo BMW::getEarly(); // Выведет: "Просто машина" (SELF остался в родителе)
echo BMW::getLate();  // Выведет: "X5" (STATIC понял, что вызвали через BMW)
```

## Механизм передачи данных в PHP. Copy-on-write
В PHP все передается по значению, но с важными нюансами:
1. **Простые типы (int, string, bool, array)** - передаются по значению с **copy-on-write**
2. **Объекты** - передается **указатель** на объект **(object handle)**, но сам механизм передачи - по значению

**Copy-on-write (копирование при записи)** - это оптимизация:
* При присваивании переменной новой переменной данные не копируются физически
* Обе переменные ссылаются на одни данные в памяти
* Копирование происходит только при изменении одной из переменных

```php
$a = 'строка'; // выделена память
$b = $a;       // память НЕ копируется, обе переменные ссылаются на одни данные
$b = 'новая';  // ТОЛЬКО сейчас создается копия в памяти

$obj1 = new MyClass(); // создан объект
$obj2 = $obj1;         // передан указатель на тот же объект
$obj2->property = 1;   // изменяется исходный объект
```
## PSR (PHP Standard Recommendations)
**PSR (PHP Standard Recommendations)** - это стандарты, разрабатываемые **PHP-FIG (PHP Framework Interop Group)** - сообществом представителей основных PHP-фреймворков

### Основные PSR:
* PSR-1, PSR-12 - стандарты кодирования
* PSR-3 - Logger interface
* PSR-4 - современный стандарт автозагрузки (заменил PSR-0)
* PSR-7 - HTTP message interfaces
* PSR-11 - Container interface

#### PSR-4
**Определяет:**
* Соответствие неймспейсов структуре директорий
* Правила автозагрузки классов
* Используется в Composer по умолчанию

**Где используется:**
* Composer (автозагрузка PSR-4)
* Все современные фреймворки (Laravel, Symfony и т.д.)
* Большинство библиотек на Packagist

## SOLID
**SOLID** - это принципы объектно-ориентированного проектирования

### Single Responsibility Principle (Принцип единой ответственности)
**Класс должен иметь только одну причину для изменения.**

Что это значит на практике:
* Каждый класс решает только одну задачу
* Изменения в одной бизнес-логике не должны затрагивать другие
* Код становится более тестируемым и поддерживаемым

**Пример нарушения:**
```php
class OrderProcessor {
    public function process(Order $order) {
        // Валидация заказа
        // Расчет стоимости
        // Сохранение в БД
        // Отправка email
        // Генерация PDF-счета
    }
}
```

**Пример соблюдения:**
```php
class OrderValidator { /* только валидация */ }
class PriceCalculator { /* только расчеты */ }
class OrderRepository { /* только работа с БД */ }
class EmailService { /* только отправка писем */ }
```

**Ключевой критерий:** Если вы можете описать работу класса без использования союза **"и"** - он вероятно соблюдает SRP

### Open-Closed Principle (Принцип Открытости/Закрытости)
**Кассы должны быть:**
* Открыты для расширения - можно добавлять новое поведение
* Закрыты для модификации - не изменять существующий код

```php
// НЕПРАВИЛЬНО - нарушает OCP
class PaymentProcessor {
    public function process($paymentType, $amount) {
        if ($paymentType === 'credit_card') {
            // обработка карты
        } elseif ($paymentType === 'paypal') {
            // обработка PayPal
        }
        // Добавление нового типа требует изменения класса!
    }
}

// ПРАВИЛЬНО - соблюдает OCP
interface PaymentMethod {
    public function process($amount);
}

class CreditCardPayment implements PaymentMethod {
    public function process($amount) { /* ... */ }
}

class PayPalPayment implements PaymentMethod {
    public function process($amount) { /* ... */ }
}

class PaymentProcessor {
    public function process(PaymentMethod $payment, $amount) {
        $payment->process($amount);
        // Новый тип платежа - новый класс, этот код не меняется
    }
}
```
**Ключевые моменты:**
* OCP достигается через интерфейсы и полиморфизм, а не только наследование
* Новый функционал добавляется созданием новых классов, а не изменением существующих
* Это основа многих паттернов (Стратегия, Декоратор и др.)

### Liskov Substitution Principle
### Interface Segregation Principle
### Dependency Inversion Principle

## REST API
**Разница хорошего от плохого примера**
### Хороший REST API:
* **Использует правильные HTTP-методы:** GET (чтение), POST (создание), PUT (полное обновление), PATCH (частичное обновление), DELETE (удаление)
* **Соблюдает идемпотентность:** GET, PUT, DELETE - идемпотентны; POST, PATCH - нет
* **Возвращает корректные HTTP-статусы:** 200, 201, 400, 401, 404, 422, 500
* **Имеет согласованную структуру URL:** /api/v1/users, /api/v1/users/{id}
* **Использует версионирование API**

### Плохой REST API:
```php
// ПЛОХО: Использует GET для изменения данных
GET /api/delete-user?id=1

// ПЛОХО: Всегда возвращает 200, даже при ошибках
{"status": 200, "error": "User not found"}

// ПЛОХО: Действия в URL вместо использования методов
POST /api/create-user
POST /api/update-user
```

В RESTful API методы HTTP должны быть направлены на ресурсы (сущности), а действия определяются HTTP-методом.

**Правильно:**
```
GET    /api/users     - получить список пользователей
POST   /api/users     - создать пользователя
GET    /api/users/1   - получить пользователя
PUT    /api/users/1   - обновить пользователя
DELETE /api/users/1   - удалить пользователя
```

**Неправильно:**
```
GET /api/get-users
GET /api/create-user?name=John
GET /api/delete-user?id=1
```

## CORS (Cross-Origin Resource Sharing)
**CORS (Cross-Origin Resource Sharing)** - это механизм безопасности браузера, который контролирует доступ к ресурсам на разных доменах.

### Проблема, которую решает:
* Браузеры по умолчанию запрещают JavaScript-запросы к API на другом домене (Same-Origin Policy)
* Это защищает пользователей от атак (например, CSRF)
* Но это же мешает работе SPA-приложений, где фронтенд и бэкенд на разных доменах

### Как работает CORS:
1. Браузер отправляет preflight-запрос (OPTIONS) перед основным запросом
2. Сервер отвечает заголовками, указывающими разрешенные:
* `Access-Control-Allow-Origin` - разрешенные домены
* `Access-Control-Allow-Methods` - разрешенные HTTP-методы
* `Access-Control-Allow-Headers` - разрешенные заголовки

**Пример в Laravel:**
```php
// В middleware Cors.php
return $next($request)
    ->header('Access-Control-Allow-Origin', 'https://frontend.com')
    ->header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE')
    ->header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
```

**Практическое значение:**
* Без правильной настройки CORS фронтенд не сможет работать с вашим API
* Нужно явно разрешать только доверенные домены
* В разработке можно временно разрешать все домены `(*)`, но в production это опасно

## Тестирование
### Unit (Модульные) тесты
* **Что тестируем:** Один класс / Один метод в вакууме (сервисы, валидаторы)
* **Зависимости:** Мокаем **ВСЕ** внешние зависимости (БД, API, другие классы)
* **БД:** Нет.
* **Внешние API:** Нет (мокаем)
* **Цель:** Проверить логику в чистом виде
* **Инструмент:** `PHPUnit`, `Mockery`.
* **Пример:** Тестируем калькулятор зарплаты. Нам не нужна база данных, чтобы проверить, что 100 + 20% = 120.

```php
// Unit-тест сервиса
public function test_calculate_total()
{
    $service = new OrderService();
    $result = $service->calculateTotal([100, 200]);
    $this->assertEquals(300, $result);
}
```

### Integration (Интеграционные) тесты
* **Что тестируем:** Взаимодействие 2+ компонентов (Сервис + Репозиторий + БД)
* **Зависимости:** Мокаем только ВНЕШНИЕ сервисы (платежные шлюзы, почта)
* **БД:** Да (реальная, но тестовая, SQLite или отдельная MySQL).
* **Внешние API:** НЕТ! (Мы их подменяем/мокаем).
* **Цель:** Проверить, что компоненты правильно работают вместе
* **Инструмент:** `Laravel Feature Tests` (`$this->get('/api/posts')`), `Symfony WebTestCase`.

**Конкретный пример интеграционного теста:**
**Сервис `PaymentProcessor,` который:**
* Сохраняет платеж в БД через репозиторий
* Отправляет запрос во внешний платежный шлюз
* Обновляет статус заказа

```php
class PaymentProcessorTest extends TestCase
{
    public function test_process_payment()
    {
        // Мокаем внешний сервис
        $gatewayMock = Mockery::mock(PaymentGateway::class);
        $gatewayMock->shouldReceive('charge')
            ->once()
            ->andReturn(['status' => 'success']);
        
        // Используем реальную БД (SQLite в памяти)
        $processor = new PaymentProcessor($gatewayMock);
        $result = $processor->process(100, 'order_123');
        
        $this->assertDatabaseHas('payments', [
            'order_id' => 'order_123',
            'status' => 'completed'
        ]);
    }
}
```

### 3. Feature (Функциональные) тесты
* **Что тестируем:** Полный пользовательский сценарий
* **Зависимости:** Мокаем только ВНЕШНИЕ сервисы
* **БД:** Да (реальная, но тестовая)
* **Внешние API:** Мокаем
* **Цель:** Проверить, что фича работает от начала до конца

```php
class OrderCreationTest extends TestCase
{
    use RefreshDatabase; // Используем реальную БД в памяти

    public function test_user_can_create_order()
    {
        // 1. Создаем пользователя (реальный, в БД)
        $user = User::factory()->create();
        $this->actingAs($user);

        // 2. Мокаем внешний платежный шлюз
        Http::fake([
            'payment-gateway.com/*' => Http::response(['transaction_id' => '123'], 200)
        ]);

        // 3. Выполняем ПОЛНЫЙ HTTP-запрос
        $response = $this->postJson('/api/orders', [
            'product_id' => 1,
            'quantity' => 2
        ]);

        // 4. Проверяем ВЕСЬ ответ
        $response->assertStatus(201)
            ->assertJsonStructure(['id', 'total', 'status', 'transaction_id']);

        // 5. Проверяем побочные эффекты (реальная БД)
        $this->assertDatabaseCount('orders', 1);
        $this->assertDatabaseHas('orders', ['status' => 'paid']);
    }
}
```
### Моки внешних HTTP-запросов:
Для внешних запросов использовать **Mockery** или встроенные моки **PHPUnit** (Laravel Http Facade fake).

**В Feature тестах (рекомендуется):**
```php
// Или в Laravel для HTTP-тестов
Http::fake([
    'api.example.com/*' => Http::response(['success' => true], 200)
]);

// Тестируем контроллер, который делает запрос к api.example.com
$response = $this->get('/api/some-endpoint');
```
**В Integration/Unit тестах (для сервисов):**
```php
// Создаем мок HTTP-клиента
$httpMock = Mockery::mock(ClientInterface::class);
$httpMock->shouldReceive('post')
    ->once()
    ->andReturn(new Response(200, [], 'OK'));

$service = new ExternalApiService($httpMock);
$result = $service->callApi();
```

### Практика в Laravel:

**Для Unit тестов:**
- Наследуем от `Tests\TestCase`
- Используем моки для ВСЕХ зависимостей
- НЕ используем фасады БД

**Для Integration тестов:**
- Наследуем от `Tests\TestCase`
- Используем реальную БД (`RefreshDatabase` трейт)
- Мокаем только внешние сервисы

**Для Feature тестов:**
- Наследуем от `Tests\TestCase`
- Используем `$this->get()`, `$this->postJson()` и т.д.
- Тестируем полные HTTP-запросы

**Про инструменты для тестирования API:**
В Laravel использовать встроенные методы для тестирования API:
```php
// Тестирование REST API эндпоинта
$response = $this->postJson('/api/v1/orders', [
    'product_id' => 1,
    'quantity' => 2
]);

$response->assertStatus(201)
    ->assertJsonStructure([
        'id', 'total', 'status'
    ])
    ->assertJsonPath('status', 'pending');
```

### Ключевое правило для запоминания:
- **Unit** → тестируем один компонент → все зависимости мокаем
- **Integration** → тестируем взаимодействие нескольких компонентов → реальная БД, но внешние API мокаем
- **Feature** → тестируем пользовательский сценарий → реальная БД, мокаем внешнее, используем HTTP-запросы

## Active Record / Data Mapper

### Active Record (Laravel / Eloquent ORM)
**Суть паттерна Active Record такая:**
* модель одновременно представляет строку таблицы и умеет сама себя сохранять/обновлять/удалять;
* то есть модель содержит данные и логику работы с БД. 
* Также модель сама может **искать/читать** данные, Репозитории являются опциональными для сложных проектов

**Пример в Laravel:**
```php
$user = User::find(1);
$user->name = 'John';
$user->save();
```
**Модель:**
* хранит поля id, name
* сама знает, как себя сохранить (save())

**Плюсы:**
* простота и скорость разработки
* естественный и красивый синтаксис
* идеально для CRUD-логики

**Минусы:**
* «магия» и плотная связь модели и БД
* сложнее писать сложные доменные модели
* не всегда удобно тестировать

### Data Mapper (Symfony / Doctrine ORM)
**Суть паттерна Data Mapper:**
* Entity (Сущность) — это просто «адаптированный объект», чистый PHP-класс без связи с БД;
* Entity Manager — отвечает за **сохранение/изменение** (`persist`, `flush`).
* Repository (Репозиторий) — отвечает только за **поиск/чтение** данных (`find`, `findOneBy`).

**Пример в Symfony:**
```php
$user = new User();
$user->setName('John');

$em->persist($user);
$em->flush();
```

**Здесь:**
* у сущности нет методов save() или delete()
* работа с БД через EntityManager

**Плюсы:**
* чище архитектура
* легче следовать DDD (Domain Driven Design)
* меньше скрытой магии

**Минусы:**
* кривее порог входа, больше конфигурации
* код менее «приятен» для простых CRUD-задач

## Logger (Логгеры) в PHP
### Базовое понятие
**Логгер** - инструмент для записи событий (логов) в приложении:
* Ошибки (errors)
* Предупреждения (warnings)
* Информационные сообщения (info)
* Отладка (debug)

### PSR-3 (стандарт)
Все современные логгеры реализуют интерфейс **PSR-3 (LoggerInterface)**.

**8 уровней логирования:**
```php
\Psr\Log\LogLevel::EMERGENCY;   // Чрезвычайная ситуация
\Psr\Log\LogLevel::ALERT;       // Тревога
\Psr\Log\LogLevel::CRITICAL;    // Критическая ошибка
\Psr\Log\LogLevel::ERROR;       // Ошибка
\Psr\Log\LogLevel::WARNING;     // Предупреждение
\Psr\Log\LogLevel::NOTICE;      // Уведомление
\Psr\Log\LogLevel::INFO;        // Информация
\Psr\Log\LogLevel::DEBUG;       // Отладка
```

**Базовые методы:**
```php
$logger->info('Пользователь залогинился', ['user_id' => 123]);
$logger->error('Ошибка БД', ['exception' => $e]);
```

### Symfony (Monolog)
Symfony использует библиотеку **Monolog** - самый популярный логгер для PHP.

**Конфигурация в Symfony:**
```yaml
# config/packages/monolog.yaml
monolog:
  channels:
    - main
    - database
  
  handlers:
    main:
      type: stream
      path: "%kernel.logs_dir%/%kernel.environment%.log"
      level: debug
      channels: ["!event"]
    
    database:
      type: stream
      path: "%kernel.logs_dir%/database.log"
      level: info
      channels: ["database"]
```

**Использование в коде:**
```php
use Psr\Log\LoggerInterface;

class SomeService
{
    private LoggerInterface $logger;
    
    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }
    
    public function someMethod()
    {
        $this->logger->info('Метод выполнен');
        $this->logger->error('Что-то пошло не так', [
            'context' => 'дополнительная информация'
        ]);
    }
}
```

### Laravel (тоже Monolog, но проще)
Laravel использует тот же **Monolog**, но предоставляет удобный фасад.

**Базовое использование:**
```php
use Illuminate\Support\Facades\Log;

Log::emergency($message);
Log::alert($message);
Log::critical($message);
Log::error($message);
Log::warning($message);
Log::notice($message);
Log::info($message);
Log::debug($message);

// С контекстом
Log::info('Пользователь зарегистрирован', ['user_id' => $user->id]);
```

**Конфигурация: config/logging.php**
```php
'channels' => [
    'stack' => [
        'driver' => 'stack',
        'channels' => ['single', 'slack'],
    ],
    
    'single' => [
        'driver' => 'single',
        'path' => storage_path('logs/laravel.log'),
        'level' => 'debug',
    ],
    
    'daily' => [
        'driver' => 'daily',
        'path' => storage_path('logs/laravel.log'),
        'level' => 'debug',
        'days' => 14,
    ],
],
```

### Паттерны в логгерах
Логгеры используют **Dependency Injection** и **Observer pattern**:
* Каждый обработчик (**handler**) - наблюдатель
* Логгер рассылает сообщения всем обработчикам

**Пример обработчиков в Monolog:**
* StreamHandler - запись в файл
* RotatingFileHandler - ротация логов
* SlackHandler - отправка в Slack
* TelegramBotHandler - отправка в Telegram
* ElasticsearchHandler - запись в Elasticsearch

## Валидация в Laravel vs Symfony
### LARAVEL: Валидация
#### Основные способы
A) В контроллере (быстрый способ)
```php
use Illuminate\Http\Request;

public function store(Request $request)
{
    $validated = $request->validate([
        'title' => 'required|string|max:255',
        'email' => 'required|email|unique:users',
        'age' => 'nullable|integer|min:18',
        'avatar' => 'image|mimes:jpg,png|max:2048',
    ]);
    
    // $validated содержит только проверенные данные
}
```

B) Form Request (рекомендуемый способ)
```php
// 1. Создаем Form Request
php artisan make:request StoreUserRequest

// 2. Редактируем app/Http/Requests/StoreUserRequest.php
class StoreUserRequest extends FormRequest
{
    public function authorize()
    {
        return true; // или проверка прав
    }
    
    public function rules()
    {
        return [
            'name' => 'required|string|max:255',
            'email' => 'required|email|unique:users,email',
            'password' => 'required|confirmed|min:8',
            'role' => 'sometimes|in:admin,user,moderator',
            'avatar' => 'nullable|image|max:2048',
            'birth_date' => 'date|before:today',
        ];
    }
    
    public function messages()
    {
        return [
            'name.required' => 'Поле имени обязательно',
            'email.unique' => 'Этот email уже занят',
        ];
    }
    
    public function attributes()
    {
        return [
            'email' => 'электронная почта',
            'password' => 'пароль',
        ];
    }
}

// 3. Используем в контроллере
public function store(StoreUserRequest $request)
{
    // Данные уже валидированы!
    $validated = $request->validated();
    
    // Или получить конкретное поле
    $name = $request->input('name');
}
```
C) Валидатор вручную
```php
use Illuminate\Support\Facades\Validator;

$validator = Validator::make($request->all(), [
    'email' => 'required|email',
    'password' => 'required|min:8',
]);

if ($validator->fails()) {
    // Перенаправление с ошибками
    return redirect()->back()
        ->withErrors($validator)
        ->withInput();
    
    // Или JSON-ответ для API
    return response()->json([
        'errors' => $validator->errors()
    ], 422);
}

$validated = $validator->validated();
```
#### Правила валидации (часто используемые)
```php
'field' => [
    // Обязательность
    'required', 'sometimes', 'nullable',
    
    // Типы данных
    'string', 'integer', 'numeric', 'boolean', 'array', 'file', 'image',
    
    // Форматы
    'email', 'url', 'ip', 'uuid', 'date', 'date_format:Y-m-d',
    
    // Длина
    'min:3', 'max:255', 'size:10', 'between:3,255',
    
    // Числовые
    'digits:10', 'digits_between:5,10', 'gt:10', 'lt:100',
    
    // Строковые
    'alpha', 'alpha_dash', 'alpha_num', 'starts_with:admin',
    'ends_with:.com', 'contains:example',
    
    // Уникальность
    'unique:users,email', // для создания
    'unique:users,email,' . $user->id, // для обновления
    
    // Существование
    'exists:users,id',
    
    // Пароли
    'confirmed', // требует поле password_confirmation
    'current_password', // проверяет текущий пароль пользователя
    
    // Файлы
    'mimes:jpg,png,pdf', 'mimetypes:text/plain',
    'max:1024', // в килобайтах для файлов
],
```

#### Кастомные правила
A) Rule объекты
```php
// Создаем правило
php artisan make:rule Uppercase

// app/Rules/Uppercase.php
class Uppercase implements Rule
{
    public function passes($attribute, $value)
    {
        return strtoupper($value) === $value;
    }
    
    public function message()
    {
        return 'Поле :attribute должно быть в верхнем регистре';
    }
}

// Используем
'name' => ['required', new Uppercase],
```

B) Closure-правила
```php
'email' => [
    'required',
    function ($attribute, $value, $fail) {
        if (!str_ends_with($value, '@company.com')) {
            $fail('Почта должна быть корпоративной (@company.com)');
        }
    },
],
```

C) Implicit правила (запускаются даже для пустых полей)
```php
class ForbiddenWords implements ImplicitRule
{
    public function passes($attribute, $value)
    {
        return !in_array($value, ['spam', 'bad']);
    }
}
```
#### Валидация массивов
```php
$rules = [
    'users.*.email' => 'required|email',
    'users.*.age' => 'required|integer|min:18',
    'tags' => 'array',
    'tags.*' => 'string|distinct|max:10',
];
```

#### Условная валидация
```php
// 1. sometimes()
$validator = Validator::make($data, [
    'email' => 'sometimes|required|email',
]);

// 2. Условные правила
$validator->sometimes('reason', 'required|max:500', function ($input) {
    return $input->status === 'rejected';
});

// 3. В Form Request
public function rules()
{
    return [
        'email' => Rule::requiredIf(function () {
            return $this->registration_method === 'email';
        }),
    ];
}
```
#### Валидация после нормализации
```php
// Подготовка данных перед валидацией
public function withValidator($validator)
{
    $validator->after(function ($validator) {
        if ($this->somethingElseIsInvalid()) {
            $validator->errors()->add('field', 'Что-то не так');
        }
    });
    
    // Нормализация
    $validator->setData(array_merge($validator->getData(), [
        'email' => strtolower($this->email),
    ]));
}
```

### SYMFONY: Валидация
#### Базовые концепции
В Symfony валидация отделена от форм и используется через компонент `symfony/validator:`
```php
use Symfony\Component\Validator\Validation;
use Symfony\Component\Validator\Constraints as Assert;
```
#### Основные способы валидации
A) Аннотации (Attributes в PHP 8+)
```php
use Symfony\Component\Validator\Constraints as Assert;

class User
{
    #[Assert\NotBlank(message: "Имя не может быть пустым")]
    #[Assert\Length(min: 2, max: 50)]
    private string $name;
    
    #[Assert\NotBlank]
    #[Assert\Email]
    private string $email;
    
    #[Assert\Range(min: 18, max: 120)]
    private int $age;
    
    #[Assert\Choice(['male', 'female', 'other'])]
    private string $gender;
    
    #[Assert\Valid] // Для вложенных объектов
    private Address $address;
}
```
B) YAML конфигурация
```yaml
# config/validator/validation.yaml
App\Entity\Product:
  properties:
    name:
      - NotBlank:
          message: 'Название обязательно'
      - Length:
          min: 3
          minMessage: 'Минимум 3 символа'
          max: 100
          maxMessage: 'Максимум 100 символов'
    price:
      - NotBlank: ~
      - Type:
          type: float
      - Positive: ~
```
C) PHP конфигурация
```php
use Symfony\Component\Validator\Mapping\ClassMetadata;

class User
{
    public static function loadValidatorMetadata(ClassMetadata $metadata)
    {
        $metadata->addPropertyConstraint('name', new Assert\NotBlank());
        $metadata->addPropertyConstraint('name', new Assert\Length([
            'min' => 2,
            'max' => 50
        ]));
    }
}
```
#### Процесс валидации
```php
use Symfony\Component\Validator\Validator\ValidatorInterface;

class UserController
{
    // 1. Внедрение валидатора через DI
    public function __construct(private ValidatorInterface $validator) {}
    
    public function create(Request $request)
    {
        $user = new User();
        $user->setName($request->get('name'));
        $user->setEmail($request->get('email'));
        
        // 2. Валидация объекта
        $violations = $this->validator->validate($user);
        
        // 3. Обработка ошибок
        if (count($violations) > 0) {
            foreach ($violations as $violation) {
                echo $violation->getPropertyPath() . ': ' . $violation->getMessage();
                // Пример: name: Это значение не должно быть пустым
            }
        }
        
        // 4. Валидация отдельных значений
        $emailViolations = $this->validator->validateValue(
            $request->get('email'),
            new Assert\Email()
        );
    }
}
```
#### Form Request в Symfony (аналог Laravel)
В Symfony это делается через DTO + валидацию:
```php
// 1. Создаем DTO
class CreateUserRequest
{
    #[Assert\NotBlank]
    #[Assert\Length(min: 2, max: 50)]
    public string $name;
    
    #[Assert\NotBlank]
    #[Assert\Email]
    public string $email;
}

// 2. Используем в контроллере
use Symfony\Component\HttpKernel\Attribute\MapRequestPayload;

class UserController
{
    #[Route('/users', methods: ['POST'])]
    public function create(
        #[MapRequestPayload] CreateUserRequest $request
    ) {
        // $request уже провалидирован автоматически
        // Если есть ошибки - вернется 422 Unprocessable Entity
    }
}
```
#### Кастомные валидаторы
```php
// 1. Создаем Constraint
#[Attribute]
class ContainsAdmin extends Constraint
{
    public string $message = 'Строка "{{ string }}" не содержит слово "admin"';
}

// 2. Создаем Validator
class ContainsAdminValidator extends ConstraintValidator
{
    public function validate($value, Constraint $constraint)
    {
        if (null === $value || '' === $value) {
            return;
        }
        
        if (!str_contains($value, 'admin')) {
            $this->context->buildViolation($constraint->message)
                ->setParameter('{{ string }}', $value)
                ->addViolation();
        }
    }
}

// 3. Используем
class User
{
    #[ContainsAdmin]
    private string $username;
}
```
#### Группы валидации
```php
// Определение групп
#[Assert\NotBlank(groups: ['create'])]
#[Assert\Length(min: 8, groups: ['create', 'update'])]
private string $password;

// Использование
$violations = $validator->validate($user, null, ['create', 'custom_group']);
```
#### Последовательная валидация
```php
#[Assert\Sequentially([
    new Assert\NotBlank(),
    new Assert\Length(min: 10),
    new Assert\Regex('/^\d+$/'),
])]
private string $phone;
```
### СРАВНЕНИЕ Laravel vs Symfony
| **Аспект**         | **Laravel**                                     | **Symfony**                           |
|--------------------|-------------------------------------------------|---------------------------------------|
| Основной подход    | Form Request + строковые правила                | Компонент Validator + аннотации       |
| Конфигурация       | Массивы в PHP                                   | Аннотации, YAML, XML, PHP             |
| Кастомные правила  | Rule объекты, Closure                           | Constraint + Validator классы         |
| Внедрение          | Form Request (DI), Validator фасад              | ValidatorInterface (DI)               |
| Ошибки             | `$validator->errors()` или `$request->errors()` | `ConstraintViolationList`             |
| Условная валидация | `sometimes()`, `Rule::requiredIf()`             | Группы валидации, Callback constraint |
| Валидация объектов | Неявная (массивы данных)                        | Явная (валидация объектов)            |
| Производительность | Быстрее для простых случаев                     | Мощнее для сложных сценариев          |

### ЧТО ГОВОРИТЬ НА СОБЕСЕДОВАНИИ
**Про Laravel:**
"В Laravel есть несколько подходов: быстрая валидация в контроллерах через validate(), более структурированный через Form Request, и ручной через Validator фасад. Form Request позволяет выносить логику валидации, авторизации и кастомных сообщений в отдельные классы. Правила можно задавать как строки, так и через Rule объекты."

**Про Symfony:**
"Symfony использует компонентный подход. Валидация через Constraint'ы, которые можно настраивать через аннотации, YAML или PHP. Основной интерфейс - ValidatorInterface, который внедряется через DI. Есть продвинутые возможности: группы валидации, последовательная проверка, кастомные constraints."

**При сравнении:**
"Laravel ориентирован на практичность и скорость разработки - простые строковые правила, удобная работа с формами. Symfony дает больше контроля и гибкости - можно валидировать любые объекты, сложные связи между полями, использовать разные форматы конфигурации."

## SQL - UNION vs UNION ALL
### Базовое определение
* **UNION** - объединение результатов двух запросов с удалением дубликатов
* **UNION ALL** - объединение результатов двух запросов сохранением всех строк

**Простой пример**
```sql
-- Таблица А: 1, 2, 3
-- Таблица Б: 3, 4, 5

-- UNION: 1, 2, 3, 4, 5 (дубль "3" удален)
-- UNION ALL: 1, 2, 3, 3, 4, 5 (все как есть)
```

### Синтаксис
```sql
-- Пример 1: Объединение клиентов из двух регионов
SELECT id, name, 'east' as region FROM customers_east
UNION  -- дубли удаляются
SELECT id, name, 'west' as region FROM customers_west;

-- Тот же запрос с UNION ALL
SELECT id, name, 'east' as region FROM customers_east
UNION ALL  -- все строки сохраняются
SELECT id, name, 'west' as region FROM customers_west;
```

### Ключевые различия
| Параметр             | UNION                                 | UNION ALL                             |
|----------------------|---------------------------------------|---------------------------------------|
| Дубликаты            | Удаляет                               | Сохраняет                             |
| Производительность   | Медленнее (сортировка+удаление)       | Быстрее (простое объединение)         |
| Использование памяти | Больше (временная таблица)            | Меньше                                |
| ORDER BY             | Можно только в конце всего UNION      | Можно только в конце всего UNION ALL  |
| Требования           | Совпадающее количество и тип столбцов | Совпадающее количество и тип столбцов |

### Важные особенности
**Порядок выполнения:**
```sql
-- Порядок строк не гарантирован без ORDER BY
SELECT name FROM table1
UNION
SELECT name FROM table2
ORDER BY name;  -- ORDER BY только в конце ВСЕГО запроса
```

**Ограничения:**
```sql
-- ❌ НЕ РАБОТАЕТ: разное количество столбцов
SELECT id, name FROM table1
UNION
SELECT id FROM table2;  -- ОШИБКА

-- ❌ НЕ РАБОТАЕТ: разные типы данных
SELECT id, name FROM table1  -- name VARCHAR
UNION
SELECT id, created_at FROM table2;  -- created_at DATETIME

-- ✅ РАБОТАЕТ: можно приводить типы
SELECT id, CAST(name AS CHAR) FROM table1
UNION
SELECT id, CAST(amount AS CHAR) FROM table2;  -- amount INT
```

### UNION vs JOIN - в чем разница?
```sql
-- UNION: строки друг под другом (вертикальное объединение)
-- JOIN: строки рядом (горизонтальное объединение)

-- UNION (вертикально)
SELECT id, name FROM employees
UNION
SELECT id, name FROM managers;

-- JOIN (горизонтально)  
SELECT e.id, e.name, d.department_name 
FROM employees e
JOIN departments d ON e.department_id = d.id;
```

### Резюме
UNION и UNION ALL используются для вертикального объединения результатов двух или более SELECT-запросов. Ключевое отличие: **UNION удаляет дубликаты**, выполняя дополнительную сортировку и дистинкцию, что влияет на производительность. **UNION ALL просто складывает все** строки, работая быстрее.

Используйте UNION, когда нужны уникальные записи из нескольких источников, например, сбор уникальных email из разных таблиц. UNION ALL подходит для сбора статистики или логов, где важна скорость и нужно сохранить все данные.

## Хинты для индексов в MySQL: USE INDEX, FORCE INDEX, IGNORE INDEX
**Хинты** — это подсказки **оптимизатору MySQL** о том, какие индексы использовать (или не использовать) при выполнении запроса.

```sql
-- Базовый синтаксис
SELECT * FROM table_name 
USE INDEX (index_name)  -- рекомендация
WHERE condition;

SELECT * FROM table_name 
FORCE INDEX (index_name) -- принуждение
WHERE condition;

SELECT * FROM table_name 
IGNORE INDEX (index_name) -- игнорирование
WHERE condition;
```

### USE INDEX — рекомендация
```sql
-- "Пожалуйста, рассмотри этот индекс"
SELECT * FROM orders 
USE INDEX (idx_customer_date)  -- предлагаем индекс
WHERE customer_id = 123 
  AND order_date > '2024-01-01';
```
**Когда использовать:**
* Оптимизатор иногда выбирает неоптимальный индекс
* У вас есть статистика, что конкретный индекс лучше
* MySQL может проигнорировать хинт, если сочтет свой план лучше

### FORCE INDEX — принуждение
```sql
-- "Обязательно используй этот индекс!"
SELECT * FROM orders 
FORCE INDEX (idx_customer_date)  -- заставляем использовать
WHERE customer_id = 123 
  AND order_date > '2024-01-01';
```
**Когда использовать:**
* Точно знаете, что конкретный индекс оптимален
* Оптимизатор упорно выбирает неправильный план
* ❌ Опасный хинт — может сильно замедлить запрос если индекс плохой

### IGNORE INDEX — игнорирование
```sql
-- "Не используй этот индекс"
SELECT * FROM orders 
IGNORE INDEX (idx_customer)  -- игнорируем индекс
WHERE customer_id = 123 
  AND status = 'pending';
```
**Когда использовать:**
* Индекс мешает (например, когда лучше full scan)
* Есть "горячие" индексы, которые кэшируются неправильно
* Для тестирования разницы в производительности

### FOR vs USE — ключевое различие
```sql
-- Пример таблицы orders с индексами:
-- PRIMARY (id)
-- idx_customer (customer_id)
-- idx_date (order_date)
-- idx_customer_date (customer_id, order_date)

-- Сценарий 1: USE INDEX (рекомендация)
SELECT * FROM orders 
USE INDEX (idx_customer_date)  -- MySQL МОЖЕТ проигнорировать
WHERE customer_id = 123;

-- Сценарий 2: FORCE INDEX (принуждение)  
SELECT * FROM orders 
FORCE INDEX (idx_customer_date)  -- MySQL ОБЯЗАН использовать
WHERE customer_id = 123;

-- Сценарий 3: Без хинта
SELECT * FROM orders  -- MySQL сам выберет idx_customer (более узкий)
WHERE customer_id = 123;
```

### Практические примеры
**Когда USE INDEX полезен:**
```sql
-- Таблица: users (id, email, created_at, status)
-- Индексы: PRIMARY(id), idx_email(email), idx_status_created(status, created_at)

-- Без хинта: может использовать idx_status_created (составной)
SELECT * FROM users 
WHERE status = 'active' 
ORDER BY created_at DESC 
LIMIT 100;

-- С хинтом: заставляем использовать правильный порядок
SELECT * FROM users 
USE INDEX (idx_status_created)  -- индекс в порядке (status, created_at)
WHERE status = 'active' 
ORDER BY created_at DESC  -- ORDER BY использует вторую часть индекса
LIMIT 100;
```

**Когда FORCE INDEX может навредить:**
```sql
-- ❌ ПЛОХО: принуждаем к индексу по дате для range-запроса
SELECT * FROM large_table 
FORCE INDEX (idx_date)  -- плохо для range + limit
WHERE date BETWEEN '2024-01-01' AND '2024-12-31'
ORDER BY id 
LIMIT 10;

-- ✅ ЛУЧШЕ: пусть оптимизатор сам решит
SELECT * FROM large_table 
WHERE date BETWEEN '2024-01-01' AND '2024-12-31'
ORDER BY id 
LIMIT 10;
```

**IGNORE INDEX для тестирования:**
```sql
-- Сравниваем производительность с индексом и без
-- Запрос 1: с индексом (по умолчанию)
SELECT * FROM products WHERE category_id = 5;

-- Запрос 2: без индекса
SELECT * FROM products 
IGNORE INDEX (idx_category)  -- игнорируем индекс по категории
WHERE category_id = 5;
```

### Когда НЕ использовать хинты
1. Вы не проанализировали запрос через EXPLAIN
2. Нет понимания, почему оптимизатор выбирает плохой план
3. База небольшая (разница будет незаметна)
4. Шаблонные запросы, которые могут измениться

### Резюме
В MySQL есть хинты для управления выбором индексов:
* USE INDEX — рекомендация оптимизатору
* FORCE INDEX — принудительное использование
* IGNORE INDEX — игнорирование индекса

Их используют, когда оптимизатор выбирает неоптимальный план запроса. Но важно:
1. Сначала анализировать через EXPLAIN
2. FORCE INDEX — крайняя мера, может ухудшить производительность
3. Часто проблема решается перестроением индексов или сбором статистики

Например, если составной индекс (status, date) не используется для ORDER BY date, можно подсказать USE INDEX.


## Event Loop и жизненный цикл JavaScript
**JavaScript** — однопоточный язык с неблокирующей асинхронной моделью. **Event Loop** — это механизм, который позволяет выполнять асинхронный код (таймеры, запросы к серверу), не блокируя основной поток

### Базовая модель (как устроен Event Loop)
1. **Call Stack (стэк вызовов)** — очередь синхронных задач. Выполняет функции по одной.
2. **Web APIs** — асинхронные операции браузера (setTimeout, fetch, DOM-события).
3. **Callback Queue (очередь коллбэков)** — сюда попадают готовые коллбэки из Web APIs.
4. **Event Loop** — бесконечный цикл, который:
 * Смотрит, пуст ли Call Stack
 * Если пуст — берёт первую задачу из Callback Queue и отправляет её в Call Stack

### Ключевые термины
* **Макрозадачи (macrotasks):** `setTimeout`, `setInterval`, `setImmediate`, I/O, UI rendering
* **Микрозадачи (microtasks):** `Promise.then/catch/finally`, `queueMicrotask`, `MutationObserver`
* Важное правило: **Микрозадачи имеют приоритет**. Event Loop сначала выполняет все микрозадачи из очереди, и только потом берёт следующую макрозадачу.

### Пример
```js
console.log('1');

setTimeout(() => console.log('2'), 0);

Promise.resolve().then(() => console.log('3'));

console.log('4');

// Порядок вывода: 1, 4, 3, 2
```
**Почему так:**
1. `1` и `4` — синхронный код, выполняется сразу
2. `setTimeout` — макрозадача, уходит в Web APIs, потом в Callback Queue
3. `Promise.then` — микрозадача, выполнится перед следующей макрозадачей
4. Event Loop сначала выполняет микрозадачу (`3`), потом макрозадачу (`2`)

### Резюме
В браузере JavaScript выполняется в одном потоке.
Чтобы при этом поддерживать асинхронность, используется event loop.
Синхронный код выполняется сразу в call stack.
Асинхронные операции — таймеры, HTTP-запросы, события — попадают в очередь задач и выполняются после того, как основной стек освободится.
Event loop постоянно проверяет, свободен ли стек, и подставляет следующую задачу из очереди.
Есть разные очереди: microtask queue (Promise, async/await) и macrotask queue (setTimeout, события).
Microtask выполняются раньше, чем macrotask, после завершения текущего синхронного кода.


## Браузерные API
### Media API (Video/Audio)
Эти API позволяют управлять медиа прямо в браузере, что разгружает сервер.

* `HTMLMediaElement` **(базовый)**: Элементы `<video>` и `<audio>`. Программное управление через JS: `play()`, `pause()`, `currentTime`.
* `MediaDevices API`: Доступ к камере и микрофону (`getUserMedia`). Зачем бэкендеру? Чтобы понимать, как на фронтенде получают поток для видеозвонков или загрузки файлов, которые потом отправятся на сервер (Laravel).
* `Web Audio API`: Для сложной обработки звука. Пример интеграции: Пользователь на фронтенде редактирует аудио, а готовый файл отправляется на бэкенд для сохранения.

### Storage API (Хранение данных)
Это API определяет, какие данные хранить на клиенте, а какие — на сервере.

* `Web Storage` (`localStorage`, `sessionStorage`)
* * `localStorage`: Постоянное хранилище (до 5-10 МБ). Зачем бэкендеру? Хранение токенов, несекретных настроек UI, чтобы не дергать API лишний раз.
* * `sessionStorage`: Хранится только в рамках вкладки.
```js
// Пример: Сохранение токена после авторизации через твой Laravel-бэкенд
localStorage.setItem('auth_token', response.data.token);
```
* `IndexedDB`: Клиентская NoSQL БД для больших объемов (сотни МБ). Зачем бэкендеру? Для офлайн-приложений (PWA). Пользователь работает без сети, данные копятся в IndexedDB, а при подключении — синхронизация с твоим API на Laravel.
* `Cookies` (хотя это не чисто JS API). Зачем бэкендеру? Ты их точно использовал. Для сессий, аутентификации. Важно понимать флаги: `HttpOnly` (безопасность), `SameSite` (защита от CSRF).

### Network API (Сеть)
Это мост между фронтендом и бэкендом.
* `Fetch API` / `XMLHttpRequest`: Отправка запросов к API сервера.
```js
// Типичный запрос к Laravel-бэкенду
fetch('/api/posts', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'X-CSRF-TOKEN': csrfToken // Защита от CSRF, которую настраиваешь
    },
    body: JSON.stringify({ title: 'New Post' })
})
.then(response => response.json())
.then(data => console.log(data));
```
* `WebSocket` (`ws`) / `Server-Sent Events (SSE)`: Для реального времени (чаты, уведомления). Зачем бэкендеру? Ты настраиваешь серверную часть (например, через Laravel Echo и WebSocket-сервер).

### Резюме
Как бэкенд-разработчик, я смотрю на браузерные API с точки зрения интеграции и разделения ответственности:
1. Для медиа понимаю, что базовое управление (`play`, `pause`) и даже захват потока с камеры происходит на клиенте, чтобы не нагружать сервер.
2. Для хранения четко вижу грань: `localStorage` — для токенов и настроек, `cookies` — для сессий с флагом `HttpOnly`, а сложные данные — всегда в моей серверной БД.
3. Сеть — это основа: `Fetch API` для общения с моим Laravel-бэкендом, обработка авторизации, ошибок. Для реального времени знаком с принципами WebSockets.

В своих проектах использовал `Fetch` для работы с API и `localStorage` для хранения токена.


## Аутентификация / Авторизация (Authentication / Authorization)
**Аутентификация (Authentication)** — это ответ на вопрос «Кто ты?» (проверка логина/пароля). Токены, сессии

**Авторизация (Authorization**) — это ответ на вопрос «Что тебе можно?» (проверка прав/ролей). Policies / middleware

В веб-разработке есть несколько основных механизмов, их выбор зависит от архитектуры приложения (монолит, SPA, мобильное приложение, микросервисы).

### Stateful (с состоянием) — Session-based Authentication
* **Как работает:** Пользователь логинится, сервер создает запись сессии (в файле, Redis, БД) и отправляет в браузер **Session ID** в cookie.
* **Заголовок:** Cookie автоматически отправляется браузером: `Cookie: laravel_session=abc123`
* **Плюсы:** Простота управления (логаут, отзыв сессии), безопасность (сессия хранится на сервере).
* **Минусы:** Плохо масштабируется (нужно хранить состояние), не подходит для нативных мобильных приложений или API для сторонних клиентов.
* **Когда использовать:** Традиционные монолитные приложения (Laravel + Blade), где фронтенд и бэкенд на одном домене.

### Stateless (без состояния) — Token-based Authentication
* **Как работает:** После успешного входа сервер генерирует токен и отдает его клиенту. Клиент хранит токен и передает его с каждым запросом.
* **Основные форматы:**
* * **Bearer Token:** Простая строка, обычно хранится в БД.
* * * **Заголовок:** `Authorization: Bearer eyJ0eXAiOiJKV1QiLC...`
* * **JWT (JSON Web Token)**: Самодостаточный токен, содержащий в себе данные (payload) и подпись. Не требует хранения на сервере.
* * * **Тот же заголовок:** `Authorization: Bearer eyJhbGciOiJIUzI1NiIs...`
* **Плюсы:** Отлично масштабируется (нет состояния на сервере), идеален для API и SPA.
* **Минусы:** Сложнее отозвать токен (для JWT нужны blacklist или короткое время жизни).
* **Когда использовать:** REST API, SPA (Vue/React), мобильные приложения.

### OAuth 2.0 / OpenID Connect (стандарт для делегирования доступа)
* **Как работает:** Пользователь авторизуется через доверенного провайдера (Google, GitHub, Yandex), который выдает **access_token** для доступа к ресурсам пользователя на другом сервисе.
* **Потоки (grants):** Authorization Code (для веб-приложений), Implicit (устарел), Password (для своих доверенных приложений), Client Credentials (для сервис-сервисного взаимодействия).
* **Когда использовать:** Когда нужно дать доступ к своему API сторонним приложениям или реализовать «Войти через Google/Facebook».

### Резюме
В моем проекте Blog API я использовал **Token-based** аутентификацию в формате **Bearer Token**, реализованную через **Laravel Sanctum**.

Почему именно такой выбор?

1. **API-first архитектура:** Проект задуман как чистый backend для будущего SPA или мобильного приложения. Токены идеально подходят для этого.
2. **Laravel Sanctum vs Passport:** Я выбрал Sanctum, потому что он легковесный и предназначен именно для SPA и мобильных приложений, где фронтенд и бэкенд — части одной системы. Passport — это полноценный OAuth2-сервер, избыточный для моей задачи.
3. **Процесс:**

* Пользователь отправляет POST-запрос на `/api/login` с email и паролем.
* Сервер проверяет credentials, генерирует токен, сохраняет его хэш в БД в таблице `personal_access_tokens`.
* Возвращает токен в ответе: `{"token": "1|abcdefgh..."}`.
* Клиент при каждом следующем запросе к защищенным эндпоинтам добавляет заголовок: `Authorization: Bearer 1|abcdefgh...`
* Сервер проверяет токен через мидлвар `auth:sanctum`.

С какими нюансами столкнулся?

* **Хранение токена на клиенте:** Для SPA Sanctum рекомендует использовать `httpOnly` куки для безопасности от XSS. Для мобильных приложений — хранить в secure storage.
* **Отзыв токенов:** Sanctum позволяет легко удалить токен из БД при логауте, что делает его невалидным.
* **Безопасность:** Все эндпоинты работали исключительно по HTTPS.

## DTO (Data Transfer Object)
**DTO (Data Transfer Object)** — это паттерн проектирования, представляющий собой объект, который инкапсулирует данные для передачи между процессами, слоями или сервисами.

**Главные черты DTO:**
* **Только данные:** Только свойства (поля) и геттеры/сеттеры. Никакой бизнес-логики, валидации или связей с БД.
* **Неизменяемость (Immutable):** Часто делается неизменяемым (через `readonly` свойства в PHP 8). Данные задаются при создании и больше не меняются. Это предотвращает побочные эффекты.
* **Сериализуемость:** Легко превращается в массив или JSON и обратно.
* **Контекстная принадлежность:** DTO знает, откуда и куда идут данные (например, `UserRegistrationDTO`, `OrderExportDTO`).

### Область применения
Основная цель — снизить **связность (coupling)** между слоями приложения. Вот главные сценарии:


| Сценарий                                   | Проблема без DTO                                                                                                                     | Решение с DTO                                                                                                        |
|--------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------|
| 1. Передача данных в Сервисный слой        | Контроллер передаёт в сервис `Request` или модель `User`. Сервис становится зависим от фреймворка (Laravel) или слоя БД.                 | Контроллер создаёт `CreateUserDTO` из `Request` и передаёт только нужные данные в сервис. Сервис становится независимым. |
| 2. Возврат данных из API                   | Контроллер возвращает модель `User` целиком (`return $user;`). Нарушается приватность, клиент получает лишние поля (пароль, `created_at`). | Контроллер создаёт `UserProfileDTO` или `UserResource`, выбирая только необходимые для API поля (`id`, `name`, `email`).       |
| 3. Взаимодействие между модулями/сервисами | Модуль "Заказы" передаёт модулю "Доставка" массив с данными. Структура массива неочевидна, её легко сломать.                         | Модули договариваются об общем `OrderDeliveryDTO`. Структура данных становится явной и контролируемой.                 |
| 4. Работа со сложными формами/запросами    | В форму приходит 15 полей, часть для `User`, часть для `Profile`. В контроллере — спагетти-код по разбору `$request->all()`.               | Создаётся `UserRegistrationDTO`, который агрегирует все данные формы в одной структуре. Контроллер становится чистым.  |

### Практический пример в Laravel
**Без DTO (типичный код):**
```php
// Контроллер сильно завязан на Request и знает слишком много
public function store(Request $request)
{
    $validated = $request->validate([...]);
    
    // Проблема: сервис зависит от Request, валидация перемешана с логикой
    $user = $this->userService->createUser(
        $request->input('name'),
        $request->input('email'),
        $request->input('password'),
        $request->input('phone'), // А это уже для профиля?
        $request->input('subscribe')
    );
}
```

**С DTO (чистая архитектура):**
```php
// 1. Создаём DTO (часто в папке App\DTOs)
class CreateUserDTO
{
    public function __construct(
        public readonly string $name,
        public readonly string $email,
        public readonly string $password,
        public readonly ?string $phone = null
    ) {}
}

// 2. В контроллере создаём DTO из Request
public function store(CreateUserRequest $formRequest) // FormRequest для валидации
{
    // Превращаем запрос в DTO
    $dto = new CreateUserDTO(
        name: $formRequest->validated('name'),
        email: $formRequest->validated('email'),
        password: bcrypt($formRequest->validated('password')),
        phone: $formRequest->validated('phone')
    );
    
    // Передаём DTO в сервис. Сервис теперь не знает о Laravel!
    $user = $this->userService->createUser($dto);
}

// 3. Сервис работает только с DTO
class UserService
{
    public function createUser(CreateUserDTO $dto): User
    {
        // Всё необходимое есть в DTO
        $user = new User([
            'name' => $dto->name,
            'email' => $dto->email,
            'password' => $dto->password
        ]);
        $user->save();
        
        if ($dto->phone) {
            $user->profile()->create(['phone' => $dto->phone]);
        }
        
        return $user;
    }
}
```

###  DTO vs Другие объекты
|              | DTO                          | Model (Eloquent)                        | Form Request                   | Resource/JsonResource                |
|--------------|------------------------------|-----------------------------------------|--------------------------------|--------------------------------------|
| Назначение   | Передача данных между слоями | Представление строки БД + бизнес-логика | Валидация входящих HTTP-данных | Форматирование данных для API (JSON) |                              |                                      |
| Логика       | ❌ Нет                        | ✅ DAO, бизнес-логика                    | ✅ Валидация                    | ✅ Трансформация данных               |
| Зависимость  | Независим (чистый PHP)       | Зависит от ORM (Eloquent)               | Зависит от фреймворка (HTTP)   | Зависит от фреймворка (сериализация) |
| Изменчивость | Обычно immutable             | Mutable (изменяемая)                    | Immutable после валидации      | Immutable                            |

**Простыми словами:**
* **Model** — это сущность предметной области (пользователь, товар). Она «живая», умеет сохраняться, удаляться, знает свои связи.
* **DTO** — это конверт с данными об этой сущности для пересылки. Сам по себе он ничего не умеет, только хранит данные.

### Когда НЕ нужно использовать DTO
1. В простых **CRUD** — если у вас 2 поля и один сервис, DTO будет over-engineering.
2. Если вы и так возвращаете модель как есть в API (но это плохая практика).
3. Когда нет разделения на слои — если весь код в контроллерах, DTO не даст преимуществ.

### Резюме

* **DTO** — это контейнер для передачи данных между слоями.
* **Цель** — уменьшить связность: контроллер не знает о моделях, сервисы не знают о Request.
* **DTO** содержит только данные, без логики.
* **Главные плюсы:** тестируемость, читаемость, безопасность (контролируешь, что передаёшь).
* В Laravel DTO часто создают из FormRequest и передают в Сервисы.

Я использую DTO для передачи данных между слоями приложения, например, из контроллера в сервис. Это позволяет отвязать сервисный слой от фреймворка (Request-объектов), сделать код более тестируемым и явно определить контракт данных. В Laravel я часто создаю DTO на основе валидированных данных из FormRequest


## Трейты (Trait) / Абстрактные классы (Abstract Class) / Интерфейсы (Interface)

| Критерий                  | Трейт (Trait)                                    | Абстрактный класс (Abstract Class)                  | Интерфейс (Interface)                                         |
|---------------------------|--------------------------------------------------|-----------------------------------------------------|---------------------------------------------------------------|
| Суть                      | Набор методов (кусок кода) для включения в класс | Неполный класс, который нельзя создать напрямую     | Контракт, список методов, которые класс обязуется реализовать |
| Ключевое слово            | `trait`                                          | `abstract` class                                    | `interface`                                                   |
| Можно создать объект?     | Нет (не класс)                                   | Нет (только унаследовать)                           | Нет (только реализовать)                                      |
| Может содержать код?      | Да (полная реализация методов)                   | Да (можно и реализацию, и абстрактные методы)       | Нет (только сигнатуры методов, без `{тела}`)                  |
| Может содержать свойства? | Да (обычные)                                     | Да (обычные и абстрактные)                          | Нет (только константы)                                        |
| Наследование              | Горизонтальное (подключение)                     | Вертикальное (один родитель)                        | Вертикальное (множественное)                                  |
| Основная задача           | Повторное использование кода                     | Определение общего поведения и частичной реализации | Определение контракта/роли                                    |                                                               |

### Трейт (Trait): "Кусок кода для повторного использования"
**Что это:** Механизм **горизонтального повторного использования кода.** Это не класс, а **сборник методов**, который можно "вклеить" в любой класс.

**Как выглядит:**
```php
trait Loggable {
    protected function log(string $message): void {
        echo '[' . date('Y-m-d H:i:s') . '] ' . $message . PHP_EOL;
    }
}

class User {
    use Loggable; // "Вклеиваем" метод log()
    
    public function save() {
        $this->log('Пользователь сохранён');
    }
}

class Order {
    use Loggable; // Тот же метод в другом классе
    
    public function process() {
        $this->log('Заказ обработан');
    }
}
```

**Основные сценарии использования:**
1. Когда нужен один и тот же код в **НЕСВЯЗАННЫХ** классах (например, логирование в `User`, `Order`, `Product`).
2. Чтобы избежать дублирования кода, когда наследование не подходит (в PHP нет множественного наследования).
3. Для разделения большой функциональности на части (например, `SoftDeletes`, `Notifiable` в Laravel Eloquent).

**Ограничения:**
* Нельзя создать экземпляр трейта.
* Конфликты имён: если два трейта имеют методы с одинаковым именем, нужно разрешать конфликт через `insteadof` или `as`.

### Абстрактный класс: "Частично готовый шаблон"
**Что это:** Класс, который **нельзя инстанцировать** напрямую, только унаследовать. Он может содержать как обычные методы с реализацией, так и **абстрактные методы** (без реализации), которые **должны** быть реализованы в дочерних классах.

**Как выглядит:**
```php
abstract class Vehicle {
    protected string $brand;
    
    // Обычный метод с реализацией
    public function setBrand(string $brand): void {
        $this->brand = $brand;
    }
    
    // Абстрактный метод БЕЗ реализации
    abstract public function move(): string;
}

class Car extends Vehicle {
    // ДОЛЖЕН реализовать абстрактный метод
    public function move(): string {
        return $this->brand . ' едет по дороге';
    }
}

class Boat extends Vehicle {
    public function move(): string {
        return $this->brand . ' плывёт по воде';
    }
}

// $vehicle = new Vehicle(); // ОШИБКА! Нельзя создать абстрактный класс
$car = new Car();
$car->setBrand('Toyota');
echo $car->move(); // "Toyota едет по дороге"
```

**Основные сценарии использования:**
1. Когда несколько классов имеют **ОБЩУЮ ЛОГИКУ**, но разную реализацию части методов.
2. Создание семейств связанных объектов с общим поведением.
3. Шаблонный метод **(Template Method)** — определение "скелета" алгоритма в абстрактном классе.

### Интерфейс: "Контракт на реализацию"
**Что это:** Контракт, который описывает **КАКИЕ** методы должен иметь класс, но не говорит **КАК** их реализовать. Класс может реализовывать много интерфейсов.

**Как выглядит:**
```php
interface LoggableInterface {
    public function log(string $message): void;
}

interface SavableInterface {
    public function save(): bool;
}

class User implements LoggableInterface, SavableInterface {
    // ОБЯЗАН реализовать ВСЕ методы интерфейсов
    public function log(string $message): void {
        file_put_contents('log.txt', $message, FILE_APPEND);
    }
    
    public function save(): bool {
        // логика сохранения
        return true;
    }
}
```

**Основные сценарии использования:**
1. Определение ролей или возможностей (`Loggable`, `Cacheable`, `Sortable`).
2. Стратегия внедрения зависимостей (Type Hinting к интерфейсу, а не к конкретному классу).
3. Принцип инверсии зависимостей (D) в **SOLID** — зависимости на абстракциях, а не на деталях.

### Практические правила: Что выбрать?
**Используй ТРЕЙТ, когда:**
* Тебе нужно **переиспользовать один и тот же код** в разных, часто несвязанных классах.
* Пример: Добавить логирование, кэширование, трейты `SoftDeletes`, `HasSlug` в Laravel.

**Используй АБСТРАКТНЫЙ КЛАСС, когда:**
* У тебя есть тесно **связанные классы** с общей логикой, но разной реализацией части методов.
* Пример: `Vehicle` → `Car`, `Boat`, `Plane` (все двигаются, но по-разному).

**Используй ИНТЕРФЕЙС, когда:**
* Тебе нужно **определить контракт**, который могут реализовать разные классы.
* Пример: `PaymentGateway` → `StripeGateway`, `PayPalGateway` (все могут принимать платежи, но реализация разная).

### Важные нюансы и примеры из Laravel
**Трейты в Laravel (где их можно подсмотреть):**
* `Illuminate\Database\Eloquent\Concerns\HasRelationships `(для связей в моделях)
* `Illuminate\Notifications\Notifiable` (для отправки уведомлений)
* `Illuminate\Auth\Authenticatable` (для аутентификации)

**Пример комбинирования всех трёх подходов:**
```php
// Интерфейс = контракт
interface Reportable {
    public function generateReport(): array;
}

// Абстрактный класс = общая логика
abstract class Report implements Reportable {
    protected string $title;
    
    public function __construct(string $title) {
        $this->title = $title;
    }
    
    // Абстрактный метод - нужно реализовать
    abstract public function generateReport(): array;
    
    // Общий метод для всех отчётов
    protected function formatData(array $data): string {
        return json_encode($data, JSON_PRETTY_PRINT);
    }
}

// Трейт = переиспользуемый код
trait LoggableReport {
    protected function logReport(string $type): void {
        Logger::info("Сгенерирован отчёт: {$type}");
    }
}

// Конкретный класс использует всё
class SalesReport extends Report {
    use LoggableReport; // Подключаем трейт
    
    public function generateReport(): array {
        $this->logReport('sales'); // Метод из трейта
        
        return [
            'title' => $this->title,
            'data' => Sales::getThisMonth(),
            'formatted' => $this->formatData(Sales::getThisMonth()) // Метод из абстрактного класса
        ];
    }
}
```

### Резюме
В PHP эти три концепции решают разные задачи:
1. Интерфейс определяет контракт (какие методы должны быть).
2. Абстрактный класс предоставляет частичную реализацию для родственных классов.
3. Трейт позволяет горизонтально переиспользовать код в несвязанных классах.

В Laravel трейты активно используются для добавления функциональности в модели (например, `SoftDeletes`), интерфейсы — для контрактов сервисов (например, `ShouldQueue` для очередей), а абстрактные классы — для базовых реализаций (например, `TestCase` в тестировании).